## 핵심 개념

### 쿠버네티스가 하는것과 안하는거

우리가 해야되는거 => 클러스터랑 노드 새엉

쿠버네티스는 최종 아키텍처를 정의하는 올인원 도구

그래서 클러스터/ 마스터노드/워커 노드 구성을 정의하고 리소스를관리할거라고 생각할수있음

쿠버네티스는 포드의 모니터링 / 포드 컨테이너의 모니터링 / 실패한 포드 교체 등 관리와 오케스트레이션에 도움이됨

쿠버네티스는 실행되어야 하는 방식으로 컨테이너와 그에 관련된것들이 실행되고 배포된 앱을 관리하는 역할을함.

앱에 필요한 인프라에대해선 전혀 관여하지않음

쿠버네티스 !== 클라우드 프로바이더

ECS 말고 EKS 사용

스케일리와 접근 도달 정도에만 관심을 가짐.

앱에 필요한 리소스는 직접 수정하거나 관리형 서비스 사용

### 설치 ￼

Minukube dashboard

실행중인 pod 등등을 확인가능 


Minikube status 

오; 알아서 한글로 나와 개신기 



이제 쿠버네티스 클러스터가 구동된 가상 머신을 갖고있으므로  상호작용 가능



### 내부동작 

아키텍쳐가 어떻게 생겼는지가 아니고 컨테이너를 시작하기위해 어떤 종류의 언어를 이해하는지 알아야됨

쿠버네티스는 객체와 함께 작동한다는 사실을 염두해두어야함.

쿠버네티스는 몇가지 객체를 알고있음 

Pods/ deployments/ service / volume 등 

특정 명령을 실행해서 이 객체를 만들수있음.  만들면 쿠버네티스는 이 객체를 취한다.

객체 생성은 두 가지 

1 명령적 방식 
2 선언적 방식 


쿠버네티스는 객체를 원하고 객체는 쿠버네티스가 뭔가를 하게 만듦

주요객체는 항상 작동함 예를들어 pod가 그러하다. 

pod의 아이디어는 하나 또는 여러 개의 컨테이너를 포함하고 실행하는것 둘 다 가능함.

pod에 하나 또는 여러개의 컨테이너가 있을 수 있음.

컨테이너를 실행해서 클러스터위의 노드에 알려줘야됨. 

가장 중요한 볼륨 같은것들을 pod에서 공유함.
 
Pod도 클러스터의 일부라서 pod나 외부 세계와 통신이 가능하다. 

pod에는 클러스터 내부 ip가있음 (변경가능 )


AWS ECS의 태스크는 쿠버네티스의 Pod와 매우 비슷함.




### Deployment 객체

주요객체중 하나. 
일반적으로 Pod을 수동생성 안함

Deployment 만들어 관리해야되는 pod의 수와 컨테이너 수를 제어함.

Controls (multiple) pods
- 기능 
원하는 목표 설정.
멈추거나 삭제 / 롤 백 가능 
동적 스케일링 가능


일반적으로 pod를 직접 생성하지도 않고 관리하지도않음.



앱을 기반으로 이미지 배포하려면 여전히 도커를 사용해야됨

왜냐면 쿠버네티스는 이미지를 위한것이니까 


이미지를 쿠버네티스로 빌드하고나서 보낼것임. 



1. 클러스터 확인중인지 확인 
    1. Minikube status
    2. 안켜져있다면 키셈
        1. Minikube start -driver= 
        2. 까지만 입력해도지가알아서잡던데나는 입력시 virtualbox or docker 근데 vm은 m1 이랑 호환이안되는듯 안깔림 
2. kubectl(로컬머신에서 사용하는 명령어) create deployment <이미지이름> —image=<이미지>

Kubectl get deployments 

Ready 0/1  => 이미 하나 fail

Kuebectl get pods 


Kubectl delete deployment <app>



### kubectl 작동배경


객체생성후 자동적으로 클러스터에있는 마스터노드 즉 컨트롤플레인으로 전송함.
마스터 노드는 클러스터에 필요한 모든것을 생성함.

마스터모드의 스케쥴러가 실행중인 pod를 분석해서 가장 적합한 node를 찾음.



### 서비스 오브젝트

클러스터의 다른 pod에 pod를 노출함

pod는 디폴트로 이미 내부 ip주소가 있음.

대시보드에있음 

내부ip 주소에는 두가지 문제가있음 

1. 클러스터 외부에서 Pod에 액세스하는 사용할 수 없음 
2. pod가 교체될 때마다 변경됨 


service는 pod를 그룹화하고 공유 주소, 공유 ip주소를 제공함.


service를 사용해서 pod를 service로 이동시키고 서비스에서는 변경안되는 ip를 할당

클러스터 내부뿐아니라 외부에서도 변경되지않는 이 주소를 노출하도록 서비스에 지시 가능 

이를 통해 외부에서도 접근 가능 

service가 없으면 pod 에 접근하기 힘듦 => 아이피 계속 변하니까. 

생성된 아이를 전달 => kubectl expose deployment first-app —port=8080 —type=NodePort



deployment에 의해 생성된 애를 전달 

type옵션
ClusterIp?=> default 클러스터 내부에서만 접근 가능 
NodePort? => 실행중인 워커노드의 IP주소를 통해 노출됨을 의미 
LoadBalancer? => 인프라에 존재하는 로드밸런서 사용 \ 그리고 전부 일정하게 분산되도록함 

Kubectl get services 를 사용하여 역시나 확인가능 


맨아래에있는 kubernetes로 되어있는건 우리가 만든게 아니라 자동생성된거. 

클라우드 프로바이더로 배포하면 실제 노출 ip가있지만 로컬에선 항상 pending 


로컬에선 미니큐브에게 알려야. 
Minikube service <deployment serviceName>

오 무친 켜졌다 개신기 

### 컨테이너 재시작 

아 node js 에서 process.exit(1)으로 일정 라우트에서 종료 시키는 페이지가있으면 들어가면 알아서 자동으로 재시작을함.

deployment를 생성했기때문에 pod와 컨테이너가 모니터링되고 실패하면 재시작함.

개똑똑하네


Kubectl get pods 하면 실제 재시작 되는거볼수있음 혹은 이벤트로그 확인 



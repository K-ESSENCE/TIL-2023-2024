### 데이터 카테고리 / 다양한 종류의 데이터 이해

application => 소스코드가 실행되는 곳 / 코드+환경

제공되는곳 => 개발자

이코드와 전체환경이 빌드 단계에 이미지에 추가됨

즉 이미지가 빌드할때 코드가 이미지에 복사가된다. => 이 설정을 위한게 dockerfile이였음

이미지를 기반으로 컨테이너를 실행할때

컨테이너는 제공된 환경에서 우리의 코드를 사용

모든것들은 이미지에 복사하면 더이상 변경 불가.=> 이미지는 readonly 명령 실행되면 잠김

즉 새로운것을 변경하려면 이미지를 빌드해야됨

임시 애플리케이션 데이터 => 우리 소스코드가아닌 애플리케이션이 실행되는 동안 생성된 데이터를 의미

ex\_ 폼에 뭔가 입력하고 실행중인 서버컨테이너에서 처리하면 그 사용자 데이터가 임시데이터 => 코드 변수에 저장되거나 데이터베이스에 저장될수있음

일시적일뿐이니 컨테이너가꺼지면 사라져도됨

이미지가 아닌 컨테이너에 저장된다는 것은 부가 extra 레이어에 대해서 이야기하는것임

이미지 위에 도커에 의해 추가된 것

부가 레이어는 기본적으로 로직이라고 할 수 있는데 이미지를 인식하고 이미지 파일 시스템을 인식하여

복사하지않고 파일 시스템을 미러링함

이미지에서 변경안하고 부가레이어에서 실제로 read-write를한다. 배후에 일어나는일이긴함

마지막으로 영구 애플리케이션 데이터 => 지속되어야 하는 데이터 실행중인 컨테이너에서 가져와 생성함

저장되어야 되고 컨테이너 중지되고 다시실행되도 있어야함.

영구앱 데이터는 앱이 실행되는 동안 작성되지만 영구적이어야됨. 그게 **볼륨**

dockerizing 도커화

컨테이너나 이미지와 로컬파일시스템 간에는 서로 연결되어있지않음

이미지를 초기화할때 파이의 로컬 폴더랑 스냅샷을 복구할수있지만 연결이없기떄문에 그걸로 끝

만일 도커 컨테이너를 삭제하지않고 stop만하면 껏다켰을때 파일 존재.

이 격리 개념

이미지를 빌드하는 dockerfile

### 볼륨 소개

도커네는 볼륨이라는 내장 기능이 있음 => 데이터 유지를 돕는다.

애플리케이션에서 볼륨을 어떻게 활용하는가

볼륨은 호스트 머신의 폴더임

컨테이너나 이미지에 있는게아님 호스트 컴퓨터에 장착된 하드 드라이브에 존재하여 사용가능하거나, 컨테이너로 매핑되는것임

볼륨은 도커가 인식하는 호스트머신인 우리의 컴퓨터에있는 폴더로써.

도커 컨테이너 내부의 폴더에 매핑됨

like sound dockerfile Copy

하지만 이 명령어는 파일의 스냅샷을 취하고 이미지에 복사하는게 전부임

볼륨은 다름 컨테이너 내부의 폴더를 호스트 머신상의 컨테이너 외부 폴더에 연결 가능

두 폴더의 변경사항은 다른 폴더에 반영

호스트머신에 파일을 넣으면 컨테이너 내부에서 액세스 할 수 있고 컨테이너가 매핑된 경로에 파일을 추가하면 컨테이너 외부 즉 호스트 머신에서도 사용할 수 있다.

볼륨은 컨테이너가 종료된 이후에도 존재.

컨테이너가 제거되어도 볼륨은 유지된다.

### 볼륨 추가

볼륨을 추가하는 가장 쉬운 방법은 dockerfile에 특수한명령어를 넣는것

VOLUME 명령어

역시나 string[]을 취함

VOLUME ["컨테이너내부경로(생존할데이터의위치)"]

노드의 fs. rename 메서드는 다수의장치를 거쳐 이동하기에 적합하지않다.

fs.rename => fe.copyFile
++ await fs.unlink(tempFilePath);

본질적으로 파일을 복사하고 수동으로 삭제

뭐야 안되잖아

### 저장 메커니즘

도커에는 두가지 외부 저장 메커니즘이있음

볼륨 / 바인드 마운트

볼륨은 도커에 의해 관리되고 바인드 마운트는 나에의해.

볼륨에는
named 볼륨이 있고 익명 볼륨이있음

그전에는 내부 경로만 정하고 호스트머신의 경로는 정하지않음 그래서 미러링된 폴더의 위치를 우리는 모름

이 볼륨에 엑세스하는 유일한 방법은 docker volume 명령어
docker volume ls 하면 볼륨 볼수있음 이역시 아이디값 처럼 들어가있다.

익명볼륨과 모든 바인드 마운트는 하나의 핵심 개념을 공유하게됨

컨테이너에 정의된 경로는 어떤 볼륨에 매핑이됨

그래서 호스트 머신상 생성경로로 연결됨

VOLUME ["컨테이너내부경로(생존할데이터의위치)"]

이건 실제로 호스트머신의 어딘가에 매핑이됨(우리는 그 경로를 모름)

named 볼륨을 쓰면 컨테이너가 종료된 후에도 볼륨이 유지됨 => 하드드라이브 가 그대로 유지됨

그뒤에 다시 컨테이너가 실행되면 볼륨이 복구되고 모든 데이터를 여전히 사용가능

그래서 named 볼륨은 영구적이어야 하는 데이터나 편집하거나 직접 볼 필요가 없는 중요한 데이터에 적합함

실질적으로 호스트 머신의 폴더에 액세스하지 않을 것이기때문에

docker run -v ${named}:/app/feedback

이런식으로 매핑

:으로 분기

컨테이너가 제거되면 익명불름은 자동으로 제거가됨 --rm 옵션 일경우 그렇다

--rm옵션이없다면 익명볼륨은 제거되지 않는다.

그리고 새로시작하면 이전에만들어뒀던게 아니라 또 새로운걸 만들기떄문에 볼륨이쌓임

docker volume rm NAME명령어나

docker volume prune 명령어로 정리

### 바인드 마운트

바인드 마운트는 볼륨과 비슷하지만
도커에 의해관리되는 볼륨의 위치를 우리는 모르지만
바인드 마운트의 경우는 우리가 알고있음

우리가 개발자로써 호스트 머신 상에 매핑될 컨테이너의 경로를 설정하기 떄문임

바인드 마운트는 영구적이고 편집가능한 데이터에 적합함

named 볼륨도 영구적이지만 이건 편집불가능한 데이터 (어디에 저장되어있는지도모르니까)

바인드 마운트 추가 하는법? => dockerfile은 아님

이미지가 아니라 컨테이너에만 적용되기떄문에

컨테이너가 실행될때 터미널 내부에서 바인드 마운트를 설정해야됨

-v named 말고 두번쨰 볼륨을 또 추가 가능

이떄이전과는 다르게 : 앞에 절대경로를 붙여야된다.

절대경로에 double qoute 로 감싸는것도 좋음 경로에 공백이나 특이한게있으면 ㅇㅇ

도커의 기본설정에 액세스해서

FILE SHARING에 공유하고있는 폴더가 리스팅되어있는지 확인 필요

왜없나 했더니 윈도우에는 없음
--rm 옵션이있으면 끄고나서 -ps 로도 안잡힘

```
macOS / Linux: -v $(pwd):/app

Windows: -v "%cd%":/app

```

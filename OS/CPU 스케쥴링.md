컴퓨터 프로그램이 실행되면

CPU 인스트럭션이 실행되는단계와

오래걸리는 IO 단계 가 번걸아가며실행되는게

모든 프로그램의 경로다.

물론 프로그램마다 다르긴하다.

CPU 인스트럭션 실행단계 CPU버스트 (CPU연속적으로쓰는것)

CPU버스트가짧다 -> IO가 많이 필요하다.

CPU버스트가 길다 -> IO 가 거의 끼어들지않는다.

누구한테 줄건지가 CPU 스케쥴링

크게 두가지문제

1.여럿이 있는데 누구한테 당장 줄건가

2.프로그램이 CPU다쓰고 나갈떄까지 계속주냐 아니면 너무기니까 중간에 뻇어서 넘겨주냐는 두 가지 이슈

특히 두번째 이슈는 CPU 버스트가 긴 애한테 한번 넘어가면 IO 바운드 잡 이 조금만 CPU 쓰고 바로 나갈것임에도 불구하고 뒤에가 다밀려버리는 일이 생겨버림

1. 강제로 CPU를 뺴앗지않는 방법

자진반납할떄까지 보장하는것 그것을 넌프린티브한 스케쥴링이라고 함

=> 번역체로 비선점형 이라는 말을 쓴다.

2. 강제로 빼앗는 방법

강제로 빼앗는 수단으로 timer 인터럽트가있다는것을 이미 설명함(선점형)

현대적인 CPU 스케쥴링은 선점형을 쓰고있음

### 스케쥴링 알고리즘

어떤게 좋은지 어떻게 아는가? => 성능척도 => CPU를 위한 성능척도임

CPU스케쥴링의 성능 척도로는

1. 시스템입장에서의 성능 척도

시스템입장에서는 CPU하나가지고 최대한 일을 많이시키면 좋은 것
=> 이용률, 처리량

CPU이용률은 전체시간 중 CPU가 놀지않고 일한 비율

처리량 은 주어진시간에 몇개의 일을 했느냐 를 나타냄

2. 프로그램 입장에서의 성능 척도
   CPU를 빨리얻어서 빨리 끝나는것
   => 소요시간, 대기시간, 응답시간 같은 시간과 관련된 성능 지표

시간관련 세가지는 고객입장.

가능하면 내가 먼저 잡아서 io를 나가는

프로세스입장에서의 성능은 시간. turnaround time 소요시간 반환 시간

순수하게 줄 서서 기다린 시간 웨이팅 타임

응답 시간 => readyQueue 에 들어와서 처음으로 CPU를 얻는데 까지 걸린 시간

CPU를 얻었다 뺐었다 하는 것의 경우 CPU를 처음으로 얻는시간 이 굉장히 의미있어서 응답시간이 별도로있다.

중국집에 비유하면

중국집 주인이면 주방장 일을 많이시키는게 좋다

주방장이 놀지않고 일하는게 이용률 , 중국집에서 손님 몇명이나 시간당 내보내는가 가 처리량

손님입장에서 중국집에 밥먹으러 들어와서 주문하고 다먹고 나가면 반환시간, 소요시간

손님이 기다리는 시간 웨이팅 타임

첫번째 음식이 나올떄까지 기다리는 시간 이 응답시간(단무지라도 하나 주면 그걸 먹고 허기를 달래는)

### FCFS

first-comt-first-served

먼저온 고객을 먼저 서비스해주는 스케쥴링 방법

사실 스케쥴링 방법이라고 하기도 민망

그냥 먼저온 순서대로 처리한다.
?

FIFO?

이건 비선점형 . 강제롱 안뺐음

FCFS는 그래서 별로 썩 효율적이지는 않다.

앞에 녀석이 뭘하냐에따라서 기다리는 시간에 영향이 간다.

이런현상을 Convoy Effect라고 부른다.

굳이 우리 말로 번역하면 호의 효과

queue에서 오래기다리는 현상을 아무튼 컴퓨터 시스템에서 convoy effect라고 부른다.

### SJF

cpu를 짧게 주는 애한테 먼저주는 스케쥴링

shortest- job -first

cpu사용하는 시간이 cpu 버스트가 제일 짧은 애한테 cpu를 주는 스케쥴링

이러면 전체적으로 행복한 결과가 나온다.

평균 웨이팅 타임을 최소화 하는 알고리즘

SJF 방식도 두가지를 나눠서 생각해볼 수 있다.

SJF도 비선점형 방식으로 하면 더 짧은 애가 오더라도 안넘겨줌

넌프린티브

프림티브한 방법은 선점형 CPU를 줬더라도 더 짧은 애가 오면 걔한테 넘겨줌

SJF 안에서 비선점 선점 두개 다 잇다.
preemtive

nonpreemtive

32:50 SJF 예제 도착한 시간이 다 다름

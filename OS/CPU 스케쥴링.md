컴퓨터 프로그램이 실행되면

CPU 인스트럭션이 실행되는단계와

오래걸리는 IO 단계 가 번걸아가며실행되는게

모든 프로그램의 경로다.

물론 프로그램마다 다르긴하다.

CPU 인스트럭션 실행단계 CPU버스트 (CPU연속적으로쓰는것)

CPU버스트가짧다 -> IO가 많이 필요하다.

CPU버스트가 길다 -> IO 가 거의 끼어들지않는다.

누구한테 줄건지가 CPU 스케쥴링

크게 두가지문제

1.여럿이 있는데 누구한테 당장 줄건가

2.프로그램이 CPU다쓰고 나갈떄까지 계속주냐 아니면 너무기니까 중간에 뻇어서 넘겨주냐는 두 가지 이슈

특히 두번째 이슈는 CPU 버스트가 긴 애한테 한번 넘어가면 IO 바운드 잡 이 조금만 CPU 쓰고 바로 나갈것임에도 불구하고 뒤에가 다밀려버리는 일이 생겨버림

1. 강제로 CPU를 뺴앗지않는 방법

자진반납할떄까지 보장하는것 그것을 넌프린티브한 스케쥴링이라고 함

=> 번역체로 비선점형 이라는 말을 쓴다.

2. 강제로 빼앗는 방법

강제로 빼앗는 수단으로 timer 인터럽트가있다는것을 이미 설명함(선점형)

현대적인 CPU 스케쥴링은 선점형을 쓰고있음

### 스케쥴링 알고리즘

어떤게 좋은지 어떻게 아는가? => 성능척도 => CPU를 위한 성능척도임

CPU스케쥴링의 성능 척도로는

1. 시스템입장에서의 성능 척도

시스템입장에서는 CPU하나가지고 최대한 일을 많이시키면 좋은 것
=> 이용률, 처리량

CPU이용률은 전체시간 중 CPU가 놀지않고 일한 비율

처리량 은 주어진시간에 몇개의 일을 했느냐 를 나타냄

2. 프로그램 입장에서의 성능 척도
   CPU를 빨리얻어서 빨리 끝나는것
   => 소요시간, 대기시간, 응답시간 같은 시간과 관련된 성능 지표

시간관련 세가지는 고객입장.

가능하면 내가 먼저 잡아서 io를 나가는

프로세스입장에서의 성능은 시간. turnaround time 소요시간 반환 시간

순수하게 줄 서서 기다린 시간 웨이팅 타임

응답 시간 => readyQueue 에 들어와서 처음으로 CPU를 얻는데 까지 걸린 시간

CPU를 얻었다 뺐었다 하는 것의 경우 CPU를 처음으로 얻는시간 이 굉장히 의미있어서 응답시간이 별도로있다.

중국집에 비유하면

중국집 주인이면 주방장 일을 많이시키는게 좋다

주방장이 놀지않고 일하는게 이용률 , 중국집에서 손님 몇명이나 시간당 내보내는가 가 처리량

손님입장에서 중국집에 밥먹으러 들어와서 주문하고 다먹고 나가면 반환시간, 소요시간

손님이 기다리는 시간 웨이팅 타임

첫번째 음식이 나올떄까지 기다리는 시간 이 응답시간(단무지라도 하나 주면 그걸 먹고 허기를 달래는)

19:36

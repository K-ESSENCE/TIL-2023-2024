### 메모리 관리

메모리라는건 주소를 통해서 접근하는 매체.

메모리에는 주소가 매겨짐.

주소를 크게 두가지로 나누면 첫번째가 논리적인 주소이고
두번째는 물리적인 주소.

프로그램이 실행되면 독자적인 주소공간이 형성된다.

이런식으로 프로그램마다 가지고있는게 가상주소이고 동시에 논리적인 주소라고 말함.

프로그램이 실행되면 논리주소를 가지고있음 물리주소는 실제 물리적인 주소 메모리에 프로그램이 어디로올라가느냐 이게 물리

어짜피 물리는 하나로 관리되기때문에.

실행이 되려면 물리적인 메모리 어딘가로 가야되고.

이런 주소를 결정하는것을 주소 바인딩이라고하기도함.

로지컬에서 물리적으로 넘어가는 이 시점이 언제인가?

프로그래밍을 할때 메모리 특정위치에 변수를 저장하지만 메모리 몇번지에다가 저장하는게 아니라 어떤 이름에 변수 뭐를 저장해라.

이런식으로 저장한다.

프로그래머 입장에서는 숫자로 된 주소를 사용하지않고 심볼로 된 주소를 사용함

이걸 심볼릭 어드레스 라고한다.

이게 컴파일 되면 숫자로 된 주소로 바뀐다.

주소 변환이 이루어지는 시점이 3가지 가 있다.

컴파일 타임 바인딩=> 이건 컴파일 시점

로드 타임 바인딩 => 실행 시작될때

익스큐션 타임 바인딩 => 혹은 런타임 바인딩

심볼릭 어드레스 였던 소스코드가 컴파일 되면 실행파일에서는 로지컬 어드레스가 된다.
![Alt text](image-65.png)

컴파일 시점에 이미 물리적인 주소는 정해지는 것임.

컴파일 타임 바인딩을 쓰게되면 프로그램을 물리적인 메모리에 올릴떄는 항상 이미 결정된 주소로 올려야된다.

물리적인 메모리에 다른 주소는 비어있음에도 불구하고 항상 이프로그램은 같은 위치에만 걸려야되는게 컴파일 타임에서 미리 결정되어서 대단히 비효율적임.

지금의 컴퓨터 시스템에선 컴파일 타임 바인딩을 하진않지만 예전에 컴터안에서 하나만 실행되던떄는 물리적인메모리를 컴파일할때 확정시키곤했다.

두번째가 로드 타임 바인딩.

프로그램이 시작되서 메모리에 올라갈때 물리적인 메모리 주소가 결정되는것.

컴파일타임에는 논리적인주소만 결정하고 실행시작하면 500이 비어있더라하면 500부터 넣는.

세번쨰 런타임 바인딩은. 로드타임처럼 실행시에 주소가 결정되는건 똑같은데
주소가 실행도중아 바뀔 수있음.

지금의 컴퓨터 시스템은 런타임 바인딩

컴파일 타임 바인딩을 사용할 때는 논리적이면서도 물리적인 주소에 픽스되는것이기때문에

컴파일 타임 바인딩에 의해서 생긴코드를 절대로드라고 말함 (absolute code)

load time binding 은 재배치 가능 코드 라고 해서 항상 수정 위치에 올라가는게 아니라 실행시에 어느위치든지 올라갈수있는코드라는것.

컴파일이나 로드는 실행될떄 주소가 결정되는데

런타임은 실행중에도 주소가 바뀜

그래서 메모리 주소를 요청할때마다 주소를 체크해야됨.

cpu가 바라보는 주소는 로지컬 어드레스임.

컴파일된 코드 자체에 들어간 것 까지는 못바꿈.

메모리에 올라갈떄 시작위치는 바뀌지만 안에있는 코드상의 주소는 로지컬 어드레스로 남아있으 수밖에없다.

즉 cpu가 바라보는것도 로지컬일수밖에없음.

몇번지 달라고하면 그때 주소변환해서 cpu 한테 전달을함.

런타임 바인딩부터는 그때마다 주소변환이 필요해서 주소변환용 하드웨어가 필요함.

이걸 MMU 라고 한다

### MMU

![Alt text](image-66.png)

os의 모듈이 아니고 하드웨어임

프로그램이 메모리에 올라갈때 통째로 올라가는걸 설명한게 여지껏했던것들.

주소변환을 할때에는 기본적인 mmu에서는 레지스터 2개를 활용해서 주소변환을 하게된다.

cpu가 메모리 346번쨰에있는 내용을 달라 하면 이게 로지컬 어드레스

주소변환이 필요한데 이 주소변환을 해주는게 mmu고 가장 간단한게 레지스터 2개

그 두개는 리로케이션 레지스터(베이스 레지스터) 와 리미트 레지스터 두개를 이용해서 주소변환을한다.

![Alt text](image-67.png)

주소변환은 어떻게해주면되느냐.

시작위치 -> 14000 하고논리주소를 더해주면됨
14000이 버츄얼의 0 이기떄문에 14346

그림상으로는 그렇다.

리미트 레지스터는 이 프로그램의 크기를 담고있는것(3000)

이프로그램이 악의적인 프로그램이라서 3000임에도 불구하고 인스트럭션을 통해서 메모리 4000번쨰 달라고하면

프로그램 p1 이 아니라 그바깥이 될것임.

있지도 않은 4000을 달라고할시에 ㅇ

다른 프로그램 메모리 위치를 요청하게됨. 그런경우에는? 주면안됨 남의프로그램 메모리를 보려고하는 악의적인 프로개름이기떄문

![Alt text](image-68.png)

그래서 cpu가 주게되면 리미트 레지스터 가 프로그램 크기보다 큰지. 확인하고 틀리면 트랩이걸리게됨

운영체제는 트랩이 왜 걸렸는지 확인해보고 응징을한다.

로지컬 어드레스가 크기이내에 있는것이였다면 리로케이션 거쳣 cpu 에 ㅈㄴ달

그게 바로 mmu scheme

사용자 프로그램은 로지컬 어드레스만 다루며 실제 물리주소를 볼 수없으며 알 필요도 없음

### Dynamic Loading

동적로딩

프로그램을 메모리에 올려야 실행이되는데 메모리에 동적으로 올린다.는것은? => 그때그때 필요할 떄마다 메모리에 올리는것

대게 프로그램은 방어적으로 만들어지기떄문에
좋은 소프트웨어일수록 이상한것이 들어와도 처리가 잘됨

미리 올려놓는게 아니라 그런 상황이 생기면 그때 올려놓는 것을 활용

페이징 시스템은 운영체제가 직접관리

보통 다이나믹 로딩이라함은 운영체제가하는게 아니고 프로그래머가 직접함

운영체제가 다이나믹 로딩을 쉽게할수있게 제공하면 라이브러리 써서 만듦

### Overlays

내용만 보면 다이나믹 로딩이랑 비슷한데

다른것은 ? =>역사적으로 다름

초창기 컴퓨터시스템에 메모리 크기가 워낙 작아서 프로그램하나를 올려놓는것조차 불가능했다.

그래서 초창기에 프로그래머가 수작업으로 구현함.
그래서 매우 복잡하고 다른말로 매뉴얼오버레이라고함

다이나믹은 프로그래머가 라이브러리로 해서 자세히알필요없고
오버레이는 다알아야되고

### Swapping

프로세스를 메모리에서 통째로 쫓아내는 것
어디로? => 하드디스크로
이걸 backing store , swap area라고도 부른다.

메모리에서 쫓겨나서 백킹스토어로 내려가는걸 스왑 아웃이라고하고
백킹 스토어에서 올라오는걸 스왑인이라고함.

중기스케쥴러를 다른말로 스왑퍼 라고 부르기도함.

메모리에 너무많은 프로그램이 올라와있으면 시스템이 굉장히 비효율적이 되기때문에. 중기 스케쥴러가 일부 프로그램을 골라서 통째로 메모리에서 쫓아내는 일을 하게됨

어떤 프로그램을 쫓아내야한다면 cpu 소요가능성이낮은 애를 스왑아웃시키는게 효율적일것.

스와핑 시스템이 지원이 되기위해선 바인딩과 연결해서 생각해봐야됨

컴파일 타임 바인딩이나 로드 타임 바인딩이 사용이 되고있다면
스와핑에서 쫓겨났다가 메모리로 돌아올때는 원래위치로 와야된다.

스와핑이 좀더 효율적으로 동작하려면 런타임바인딩이 지원이되어야됨.

300에서 쫓겨나면 나중에 메모리에 올라갈때 다른위치로도 갈수있어야.

디스크 접근 시간이 대부분 양에 비례함.

본연의 스와핑의 의미는 전부 쫓겨나는거고

최근에는 페이징시스템으로 전체가 쫓겨나는게아니라 잘개 쪼개서 일부만 나가고 올라가는것도 스왑아웃됬다고 표현.

### Dynamic Linking

Linking을 실행시간 까지 미루는 기법

링킹? => 프로그램을 작성한다음에 컴파일하고 링크에서 실행파일을 만들게되는데 링크라는건 여러군대 존재하는 컴파일된 파일들을 하나로 묶는거

소스파일을 여러개 따로 코딩을해서 링킹을 하기도하고. 내가 작성안한 함수지만 필요할때 내가 불러다 쓰는 라이브러리들도 결국 링킹이되어서 실행파일이 만들어지면 내 코드안에 라이브러리가 포함되기도함.
이런식의 링킹을 Static linking이라고함

- Static linking
  라이브러리가 프로그램의 실행 파일 코드에 포함됨
  실행 파일의 크기가 커짐
  동일한 라이브러리를 각각의 프로세스가 메모리에 올리므로 메모리 낭비

- Dynamic linking
  라이브러리가 실행시 연결됨
  라이브러리 호출 부분에 라이브러리 루틴의 위치를 찾기위한 stub이라는 작은 코드를 둠
  라이브러리가 이미 메모리에 있으면 그 루틴의 주소로 가고 없으면 디스크에서 읽어옴
  운영체제의 도움이 필요함

라이브러리 위치 찾는것만 내거에다가 넣어두는것
다이나믹 링킹을 해주는것을 shared library 라고함

### Allocation of physical memory

물리적인 메모리를 어떻게 관리할 것인가.

물리적인 메모리는 낮은 주소영역에는 운영체제 커널이 항상 상주하고있고

높은 주소영역에는 사용자 프로그램이 올라가있다.

사용자 프로세스 영역의 할당방법에는 두가지가있는데

1. Contiguous allocation
   연속할당
   앞에서 봤던것들이 연속할당에 해당함.

2. Noncontiguous allocation
   불연속할당

주소공간을 잘게 쪼개서 일부는 이쪽 일부는 저쪽 그게 가능해지는것

프로그램의 주소공간을 페이지로 짤라가지고 하는게 페이징기법임

- 연속할당

연속할다도 크게 두가지가있음

1. 고정 분할

프로그램이 들어갈 사용자 메모리영역에 미리 파티션으로 나누어놓는것
낭비되는 메모리 조각이 생기게되는데

이걸외부조각 내부조각으로 나눠서 설명함.

외부조각? => 이프로그램을 메모리에 올리고싶은데 올릴려는 프록램보다 메모리 조각의 크기가 더 작아서 사용이안되면 . 프로그램이 들어갈수있는공간임에도 불구하고 너무작아서 못들어가면 외부조각

내부조각? => 프로그램의 크기가 할당되었지만 남는. 그러면 내부조각 할당은 되어있지만 사용은안되는.

지금은 외부조각이되어있지만 나중에 아주 작은 프로그램이 나와서 들어가면 또 외부조각이아닌.
그래서 그때그때마다 조각에대한 시각이달라짐.

고정분할에는 이렇게 외부와 내부조각의 문제가있다.

그러면 굳이 이렇게 고정 분할방식으로 나눌 필요가있는가?

2. 가변 분할 방식

사용자 프로그램이 들어갈 영역을 미리 안나눠놓는것

48:58 프로그램이 실행될때마다

# Disk Management & Scheduling 1

디스크 관리와 스케쥴링

디스크라는 건 어떤 구조로 되어있는가?

디스크를 구성하는 최소한의 단위는 섹터임

디스크의 섹터는 내부에서 관리하는 단위고 섹터에 데이터를 읽고쓰는건 디스크 컨트롤러가 직접관리한다.

디스크 외부에서는 접근하는 단위가 어떻게되는가 저장은 섹터에 되어있지만 외부에서는 logical block (논리적인 블럭) 단위로 보게됨.

이 논리적인 블럭이 섹터에 맵핑이되어서 들어가있는형태

디스크의 외부 / 컴퓨터 호스트의 내부에서는 디스크에 접근할때 로지컬 블럭으로 접근하며

이 로지컬 블럭은 1차원 배열처럼 생김=> 배열 몇번째에 있는 원소를 달라 이런형태

어떠한 원판에 어떠한 조각에 어떤트렉이 저장되어있을지 디스크는 결정함.

특별히 섹터 0 은 논리적인 디스크상에서도 0번에 해당하는 데 디스크의 가장 바깥쪽 실린더 가장 첫번째가 0으로 정의되도록 약속되어있음

어떤 파일 시스템을 쓰던간에 0번 섹터는 부팅과 관련된 정보가 저장이된다.

공장에서 디스크를 처음 만들게되면 디스크를 디스크 컨트롤러가읽을수있는 섹터단위로 나누어놓게됨.

이런 과정을 포매팅이라고한다. 특별히 physical formatting (low-level-formatting)이라고함

에전에 하드디스크가 작을떈 포맷할때 얼마안걸렸는데 요샌 엄청 오래걸림.

만약 하드를 구매한다면 이미 피지컬 포맷팅이 되어있음.

섹터의 앞뒤에 붙는 헤더와 트레일러에 섹터 넘버 ECC 등의 정보가 저장되며 컨트롤러가 직접 접근하고 운영한다.

ECC?=> 정말 잘 돌아가는 지 체크하는 Error-correcting code

항상 데이터가있으면 데이터 외에 메타데이터가 필요하듯이

여기에서도 디스크를 읽고쓰다보면 필요한 부가정보가 있는데 이게 헤더와 트레일러에 저장됨.

각 섹터는 header + 실제 data + trailer 로 구성

섹터단위로 묶여지는게 피지컬 포매팅

피지컬 포매팅이끝난다음에 섹터영역을 묶어서 하나의 독립적인 디스크로 만들어주는것을 로지컬 디스크라고함.

운영체제는 로지컬 디스크에 관심이있음 물리적인거말공

파티션이 끝나게되면 각각의 파티션을 파일시스템, 스왑에어리어 용도로 쓸 수있다.

해당하는 시스템에 파일시스템을 설치하는것을 로지컬 포매팅이라고부른다.

부팅의 절차에 대한 간결한 설명

처음에 전원을 켜면 메모리는 다 비어있음 근데 CPU는 메모리만 접근할 수 있는 장치이지 하드디스크는 접근을 못함

메모리 영역 중에서 전원이 나
가더라도 내용이 유지되는 소량의 메모리 부분이 ROM 인데 부팅을 위한 간단한 로더가 저장이되어있음

그래서 전원을 키면 롬을 가리키고 지시가 실행됨

어떤지시? => 하드 디스크에서 0번 섹터에있는 내용을 메모리에 올리고 실행하라고 지시
0섹터는 언제나 공통이라고했음 부트블럭 ㅇ

## Disk Scheduling

디스크를 접근하는 액세스타임은 크게 3가지 시간요소로 구성됨

1. Seek time
   헤드를 해당 실린더로 움직이는데 걸리는 시간.
2. Rotational latency
   헤드가 원하는 섹터에 도달하기까지 걸리는 회전 지연 시간
3. Transfer time
   실제 데이터의 전송 시간

대부분의 걸리는 시간은 Seek time에서 걸린다고 보면 됨.

그래서 예전에 고속으로 할려면 한번 seek해서 많은양을 읽고쓰면 디스크입장에선 효과적.

디스크의 성능을 나타낼때 Disk bandwidth 가있다.

디스크 스케쥴링은 seek time을 가능한 최소화하는것이 목표.

## Disk Scheduling Algorithm

스케쥴링 알고리즘이 구현되는건 디스크 내부가 아니라 운영체제 쪽에 존재하기때문에 정확한 디스크상의 위치는 모를 수 있음.

디스크 스케쥴러는 논리블럭 번호를 보고 그정보가 어느정도는 디스크상에 섹터위치랑 맞아떨어지기때문에 그렇게 해결한다.

디스크 내부에서도 스케쥴링하는 방법이 있긴한데 실제 구현에서는 잘 안쓴다고함.

### FCFS = > First come First Service

알고리즘이라고 하기에도 민망한게 그냥 들어온순서대로 서비스함.

### SSTF shortest Seek Time First

현재 헤드위치에서 제일 가까운 요청을 먼저 처리한다.

queue에있는 요청중에서 지금 헤드위치중 가장가까운것부터 처리.

그래서 디스크 헤드의 이동거리가 줄어드는건 사실이나, starvation문제가 생김

멀리있는애들은 차례가 안올수도있음.

### SCAN

22;11

# Disk Management & Scheduling 1

디스크 관리와 스케쥴링

디스크라는 건 어떤 구조로 되어있는가?

디스크를 구성하는 최소한의 단위는 섹터임

디스크의 섹터는 내부에서 관리하는 단위고 섹터에 데이터를 읽고쓰는건 디스크 컨트롤러가 직접관리한다.

디스크 외부에서는 접근하는 단위가 어떻게되는가 저장은 섹터에 되어있지만 외부에서는 logical block (논리적인 블럭) 단위로 보게됨.

이 논리적인 블럭이 섹터에 맵핑이되어서 들어가있는형태

디스크의 외부 / 컴퓨터 호스트의 내부에서는 디스크에 접근할때 로지컬 블럭으로 접근하며

이 로지컬 블럭은 1차원 배열처럼 생김=> 배열 몇번째에 있는 원소를 달라 이런형태

어떠한 원판에 어떠한 조각에 어떤트렉이 저장되어있을지 디스크는 결정함.

특별히 섹터 0 은 논리적인 디스크상에서도 0번에 해당하는 데 디스크의 가장 바깥쪽 실린더 가장 첫번째가 0으로 정의되도록 약속되어있음

어떤 파일 시스템을 쓰던간에 0번 섹터는 부팅과 관련된 정보가 저장이된다.

공장에서 디스크를 처음 만들게되면 디스크를 디스크 컨트롤러가읽을수있는 섹터단위로 나누어놓게됨.

이런 과정을 포매팅이라고한다. 특별히 physical formatting (low-level-formatting)이라고함

에전에 하드디스크가 작을떈 포맷할때 얼마안걸렸는데 요샌 엄청 오래걸림.

만약 하드를 구매한다면 이미 피지컬 포맷팅이 되어있음.

섹터의 앞뒤에 붙는 헤더와 트레일러에 섹터 넘버 ECC 등의 정보가 저장되며 컨트롤러가 직접 접근하고 운영한다.

ECC?=> 정말 잘 돌아가는 지 체크하는 Error-correcting code

항상 데이터가있으면 데이터 외에 메타데이터가 필요하듯이

여기에서도 디스크를 읽고쓰다보면 필요한 부가정보가 있는데 이게 헤더와 트레일러에 저장됨.

각 섹터는 header + 실제 data + trailer 로 구성

섹터단위로 묶여지는게 피지컬 포매팅

피지컬 포매팅이끝난다음에 섹터영역을 묶어서 하나의 독립적인 디스크로 만들어주는것을 로지컬 디스크라고함.

운영체제는 로지컬 디스크에 관심이있음 물리적인거말공

파티션이 끝나게되면 각각의 파티션을 파일시스템, 스왑에어리어 용도로 쓸 수있다.

해당하는 시스템에 파일시스템을 설치하는것을 로지컬 포매팅이라고부른다.

부팅의 절차에 대한 간결한 설명

처음에 전원을 켜면 메모리는 다 비어있음 근데 CPU는 메모리만 접근할 수 있는 장치이지 하드디스크는 접근을 못함

메모리 영역 중에서 전원이 나
가더라도 내용이 유지되는 소량의 메모리 부분이 ROM 인데 부팅을 위한 간단한 로더가 저장이되어있음

그래서 전원을 키면 롬을 가리키고 지시가 실행됨

어떤지시? => 하드 디스크에서 0번 섹터에있는 내용을 메모리에 올리고 실행하라고 지시
0섹터는 언제나 공통이라고했음 부트블럭 ㅇ

## Disk Scheduling

디스크를 접근하는 액세스타임은 크게 3가지 시간요소로 구성됨

1. Seek time
   헤드를 해당 실린더로 움직이는데 걸리는 시간.
2. Rotational latency
   헤드가 원하는 섹터에 도달하기까지 걸리는 회전 지연 시간
3. Transfer time
   실제 데이터의 전송 시간

대부분의 걸리는 시간은 Seek time에서 걸린다고 보면 됨.

그래서 예전에 고속으로 할려면 한번 seek해서 많은양을 읽고쓰면 디스크입장에선 효과적.

디스크의 성능을 나타낼때 Disk bandwidth 가있다.

디스크 스케쥴링은 seek time을 가능한 최소화하는것이 목표.

## Disk Scheduling Algorithm

스케쥴링 알고리즘이 구현되는건 디스크 내부가 아니라 운영체제 쪽에 존재하기때문에 정확한 디스크상의 위치는 모를 수 있음.

디스크 스케쥴러는 논리블럭 번호를 보고 그정보가 어느정도는 디스크상에 섹터위치랑 맞아떨어지기때문에 그렇게 해결한다.

디스크 내부에서도 스케쥴링하는 방법이 있긴한데 실제 구현에서는 잘 안쓴다고함.

### FCFS = > First come First Service

알고리즘이라고 하기에도 민망한게 그냥 들어온순서대로 서비스함.

### SSTF shortest Seek Time First

현재 헤드위치에서 제일 가까운 요청을 먼저 처리한다.

queue에있는 요청중에서 지금 헤드위치중 가장가까운것부터 처리.

그래서 디스크 헤드의 이동거리가 줄어드는건 사실이나, starvation문제가 생김

멀리있는애들은 차례가 안올수도있음.

### SCAN

가장 간단하면서도 획기적인 스케쥴링 방법 애니메이터 스케쥴링이라고도 불림

지금 Q에 어떤 요청이 들어왔는지랑 상관없이 상황에 좌우받지않고 줏대있는 스케쥴링방법

항상 가장 안쪽에서 바깥쪽으로 . 가는데 가는 길목에 요청이있으면 처리하고지나감

문제점: 실린더 위치에 따라 대기 시간이 다르다.
가장자리의 경우에는 끝까지 기다려야될수도.
가운데는 최악의경우 반바퀴면되는데 ㅇ

전부다 도니까 starvation 문제도 발생하지않음.

### C-SCAN

SCAN보다 균일한 대기 시간을 제공

헤드가 한쪽 끝에서 다른쪽 끝으로 이동하며 가는 길목에있는 모든 요청 처리

다른쪽 끝에 도달했으면 요청을 처리하지않고 곧바로 출발점으로 다시 이동한다.

### Ohter Algorithms

기본적으로 디스크들은 스캔에 기반한 알고리즘을 씀
출발하면서 이미 queue 에 들어와있는것은 이번에 지나가면서 처리하고 지나가는 도중에 들어오는것들은 다음번에 처리

N-SCAN
디스크 해드가 이동하면서 현재 스캔하고 똑같은데

LOOK and C-LOOK
끝까지 다가서 턴하는데 요청이없으면 끝까지 갈필요없음
더이상 요청이없다고하면 방향을틈 이게 Look
C-SCAN쓰면서 똑같이 그방향에 없다하면 쓰는게 C-look

### Disk Scheduling Algorithm의 결정

Scan C-SCAN 및 그 응용 알고리즘은 LOOK, C-LOOk 등이 일반적으로 디스크 입출력이 많은 시스템에서 효율적인 것으로 알려져있음

FIle 의 할당 방법에 따라 디스크 요청이 영향을 받음

디스크 스케쥴링 알고리즘은 필요한 경우 다른 알고리즘으로 쉽게 교체할 수있도록 OS와 별도의 모듈로 작성되는것이 바람직함

# Disk Management & Scheduling 2

## Swap Space Management

스왑 스페이스 관리에대해서

하드디스크 즉 보조기억장치를 사용하는 두가지이유

1. 메모리에 제약 (휘발성)

2. 메모리의 연장선상으로 디스크를 사용

하드디스크에서 Swap Space는 어떻게 관리되어야하는가

물리적인 디스크를 파티셔닝을 해서 로지컬 디스크를 만들수있고, 각각의 로지컬 디스크는 운영체제가 독립적인 디스크로 간주함.

그래서 각각에 스왑에어리어나 파일시스템으로 사용가능

파일시스템에 데이터를 넣는 방식등등을 했었음

물리적인 메모리연장으로 쓰는거기때문에 다시올릴때든 쫓아낼때든 빠르게 해야됨.

디스크접근 시간은 대부분 디스크 해드가 움직이는 시크타임을 줄여야되고

공간효율성보다 속도효율성이 중요함.

왜냐면 프로세스가 끝나면 그대로 내용이 사라지기때문.

## RAID

Redundant Array of Independent Disks

여러개의 디스크를 묶어서 사용하는 것.

RAID의 사용목적

- 디스크 처리 속도 향상

여러 디스크에 block의 내용을 분산저장
병렬적으로 읽어 옴

- 신뢰성 향상
  동일 정보를 여러 디스크에 중복 저장
  하나의 디스크가 고장 시 다른 디스크에서 읽어옴
  단순한 중복 저장이 아니라 일부 디스크에 parity를 저장하여 공간의 효율성을 높일 수 있다.

병렬적으로 불러오는 기법을 interleaving , striping이라고부름

하나의 디스크 고장 시 다른 디스크에서 읽어오는걸 미러링 shadowing이라고한다.

# System Structure & Program Execution 2

뭘하라는 거다 라는 기계어를 매순간 메모리에 읽어와서 실행을 한다.

메모리 어디에있는 기계어? ⇒ cpu 안에있는 레지스터중에서 메모리 주소를 가리키는 레지스터 주소가있다.

프로그램 카운터 레지스터라고하는것. 

그것이 가리키고있는 메모리 위치에서 인스터럭션을 하나 읽어와서 그걸 실행하고

그다음에 메모리는 가리키고있던  프로그램 카운터라는 레지스터는 다음 을 가리키게된다.

프로그램이 항상 순차적으로 실행되는 것은 아님

제어문같은게없으면 점프를 한다. 

점프하는 인스트럭션을 만나면 멀리있는 인스트럭션을 실행하기도 한다.

cpu 안에 가리키고있는 메모리를 실행하는

그게 cpu의 운명.

항상 프로그램카운터라는 레지스터가 가리키는 메모리주소에서 인스트럭션 하나를 실행하는 일만 하게 된다.

다음 인스트럭션을 실행하기 전에 하는게 인터럽트가 있는지 체크하는 일 

만일 인터럽트가있다면 사전작업을 멈추고. cpu를 누가 쓰고있던 상관없이 cpu 제어권이 운영체제에 넘어가게된다. 

운영체제는 인터럽트 마다. 왜 인터럽트가 걸렸는지 상황에 맞게 처리할 일들이 운영체제안에 커널 함수로 정의가되어있음 

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/a0cf4138-46fe-405e-b47b-fc5a2b5d00cc/a2ffc8b7-cd88-496f-979d-8a2b77d17293/Untitled.png)

인터럽트 벡터 ⇒ 인터럽트 종류별로 처리 루틴 주소를 갖고있는것

인터럽트 핸들러 = 처리 루틴 

실제 해야될 일이 핸들러 

인터럽트 종류별로 함수로 점프하는주소를 갖게해주는게 백터

cpu안의 모드빗이 0이냐 1이냐에 따라  0이면 기계어 전부를 사용

1일때는 한정된것만 사용 

운영체제가 cpu를 가지고있으면 0 인거고(io접근 같은)

1일때는 프로그램이 가지고있을때

사용자 프로그램이 어떻게io를 하는가 

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/a0cf4138-46fe-405e-b47b-fc5a2b5d00cc/e65cb4c3-ae96-4641-a621-d037697358a8/Untitled.png)

의도적으로 인터럽트라인을 세팅함

프로그램이 직접 필요에따라 인터럽트 라인을 세팅해서 운영체제를 부르는건 소프트웨어 인터럽트라 부르며 다른말로는 Trap이라고 부름

Trap의 종류에는 두 종류가있으면 

필요에 의해 호출하는 시스템 콜이 있고 

Excetion 이라는 오류에 의한 것이 있다. 0으로나누는 연산등은 못하게 막아두는것

그cpu가 실행못하는데 실행하려고 했기때문에 자연히 인터렙트 라인이 생기고 자동적으로 운영체제에 넘어가는것  이런 예외적인 상황에서 ㅇ

io 컨트롤러 이외에 타이머도 인터럽트를 걸수있다.

타이머가 인터럽트를 걸 수 도 있다.

운영체제가 cpu를 가지고있다가. 사용자 프로그램에게 cpu를 넘어줄때 modebit을 바꾸고 넘겨주기때문에 보안과 관련된 인스트럭션이 없을것이다. 

사용자프로그램이 cpu를 계속 쓸수도있을것  ⇒ 이러면 이 cpu를 뺏을 방법이없고

그래서 timer 라는 것을 줘서

셋팅을 세팅한다음 넘겨준다 ⇒ 할당된 시간이 끝나면 cpu한테 인터럽트를 걸어서 cpu를 뺏는다.

운영체제는 타이머인터럽트의 도움을 받아 여러프로그램을 번갈아가며 실행.

동기식 입출력과 비동기식 입출력 

동기식 입출력 (synchronous i/o )

시간적으로 맞추는것.  아닌 것 

io에서의 동기식이라 함은 io 까지 직접 가서 결과를 보고 오는걸 말함

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/a0cf4138-46fe-405e-b47b-fc5a2b5d00cc/c9c8d5fa-2fc5-4c82-b0f2-eefd63019857/Untitled.png)

두경우 모두 io가 끝났다는것을 인터럽트로 알려줌 

두개의 io가 실제로 어떤 의미를 가지느냐

하나의 프로그램을 짯는데 디스크에서 뭘 읽어와야됨 

보통은 디스크 결과를보고 그다음작업을 하게끔 짬 

결과 안보고 데이터랑 상관없이 할 수 있는 작업이 있을것임.

그동안 그 작업들을 하도록. 작업을 짤 수 있을것이다. 

write는 비동기가 잘 맞는다.

근데 동기적으로 write하고싶을때도 있다.⇒ 정말 잘 썼는지 확인하고 쓰고싶다 할때. 

오래되는 io 작업을 하는동안에 아무것도 안하고 기다리면 cpu가 낭비될테니 보통은 동기적 io요청을 한다음에.  cpu를 줘봐야 일을 못하기때문에 다른 프로세스한테 cpu를 넘겨주게됨

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/a0cf4138-46fe-405e-b47b-fc5a2b5d00cc/49dae220-0269-406c-a86e-28a53f333ebc/Untitled.png)

구현방법 2 처럼 하면 던져놓고 계속 다른데에 던져놓고 해서 여러개를 동시에 할 수있음.

### DMA 디렉트 메모리 엑세스

메모리에 접근할 수 있는 장치 

원래는 메모리에 접근할 수 있는 장치가 cpu 밖에없다.

io장치들이 cpu하고 교신할려면 인터럽트를 걸고 cpu가 이풋로 부터의 요청을 메모리로 카피 해오고 아웃풋이면 반대로 보내주기도할것임

예를들어 키보드 같은 경우에는 

인터럽트를 많이 당하면 일일 멈추고 이런게 상당한 오버헤드가 있다. 

작은일 하나하나 마다 인터럽트가 걸리면 효율적인 동작을 못하기때문에.

DMA라는 장치를 하나더 붙여놓고 메모리에 cpu 말고도 DMA도 접근하게 만들어놓음

그리고 작은 애들은 1바티으 이런애들은 버퍼에 특정 크기 가 쌓이면 그거가 한번 인터럽트를 거는데

DMA가 버퍼에있는내용을 메모리에 카피하고 블럭에 해당하는 데이터에 대한 IO가 끝나면 인터럽트를 한번 걸어서 메모리까지 올라왔다고 알려줌

그러면 CPU 가 인터럽트하는 빈도가 적어짐

DMA 빠른 입출력 장치를 메모리에 가까운 속도로 처리하기 위해 사용한다.

디바이스 컨트롤러가 디바이스의 버퍼스토리지 내용을 메모리에 block 단위로 직접 전송 

그래서 바이트가 아니라 블록 단위로 인터럽트를 발생시킨다 .

서로 다른 입출력 명령어

메모리에만 접근하는 인스트럭션이있고 io 에만 접근하는 인스터럭션이있음

메모리에만 접근하는 인스트럭션이 노드 스토어 

각 io 디바이스 별로 io 디바이스에 접근할려면 노드 스토어같은 메모리 접근하는 인스터력션에서 별개의 인스트럭션이 정의가되어있어서 그걸로 가는게일반적임

메모리주소가있듯 io 디바이스에 대한 주소가 있음 

io디바이스에 메모리주소를 매겨서 메모리 주소를 통해서 io를 할수도있음

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/a0cf4138-46fe-405e-b47b-fc5a2b5d00cc/a5fa936e-5cb1-474c-8016-c6fa929ec311/Untitled.png)

좌측은 io와 메모리 따로

우측은 io도 메모리주소의 연장주소를 붙여서 진행하는 방식 

memory mapped i/o 라고한다. 우측 

저장 장치의 계층 구조

레지스터 캐시메모리 주기억장치(dram) 보조기억장치(하드 디스크 등등)

 

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/a0cf4138-46fe-405e-b47b-fc5a2b5d00cc/646d492a-17df-49ea-b65a-3f8ab570a9e7/Untitled.png)

위에는 휘발성 

아래는 비휘발성

위에는 직접 cpu가 접근되고 아래는 아님

속도차이를 두기위해 레지스터랑 메인메모리 사이에 캐시가있음

캐시메모리는 용량이작아서 모든걸 담지는 못하고 당장 필요한것만.

보통 프로그램이라는 것은 실행 파일 형태로 파일시스템에 파일 형태로 저장되어있고

그런 실행파일을 실행시키게 되면 메모리로 올라가게되어서 프로세스가 되게된다.

그래서 실행되게함

정확하게는  물리 메모리를 거치는게 아니라 중간에 한 단계를  더 거치게 되는데 그게 바로 버츄얼 메모리 라는 단계가 됨

어떤 프로그램을 실행시키게 되면 그 프로그램에 주소공간이 형성이됨 (메모리 주소공간 0 번지 부터 시작하는. 그프로그램만의 독자적인 주소가 있는 것 )

a 라는 프로그램 b라는 프로그램 모두 독자적인 주소공간을 가짐.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/a0cf4138-46fe-405e-b47b-fc5a2b5d00cc/5016230f-f436-4325-8150-a2d52daf1a7d/Untitled.png)

각 주소공간은 code, data stack으로 구성된다

모든 프로그램은 독자적인 주소공간을 가지고있는데

이걸 물리적인 메모리에 올려서 실행을 시킨다.

커널은 컴퓨터를 켜서 부팅을 하고나면 메모리에항상 올라가있지만

사용자 프로그램들은 실행을 시키면 주소공간이 생겼다가 종료시키면 사라짐

이 프로그램을 실행시켰을때만들어진 주소공간을 물리적인 메모리에 통째로 다 올려놓는게 아님(메모리가 낭비되기에) 그래서 당장 실행된 것 만 올리고 나머진 올리지않는다. 

나중에 또 사용을 안하게되면 메모리에서 쫓아내게 된다.

경우에 따라서는 메모리에 올라와서 그냥 지워버리면 되지않고 보관하고 있어야되는게 있다.

주소 공간 중에서 필요한건 물리적인 메모리에 올려놓고 그렇지않은 부분은 디스크 에 내려놓는다.(스왑 에어리어 라는곳에)

즉 프로그램마다 만들어진 주소공간이라는것은 머릿속에만 있는 주소공간이지 실제로 연속적으로 어디에 할당되는게 아니라 쪼개져가지고 어떤 부분은 여기 저기에 가있는 그런 형태.

그래서 버츄얼 메모리라고 부른다.

 

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/a0cf4138-46fe-405e-b47b-fc5a2b5d00cc/bf9db7d2-559f-4fb7-8fec-ce26ef6e8646/Untitled.png)

메인메모리의 연장공간으로 하드디스크 사용하는건 스왑에어리어 용도로 쓴다고 함

버츄얼 메모리 라고 하는건 각 프로그램마다 독자적으로 가지고있는 것

하드디스크가 

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/a0cf4138-46fe-405e-b47b-fc5a2b5d00cc/a13d8692-0dfc-496b-a70f-7a080fcddc2e/Untitled.png)

요 두가지가있는데

파일시스템 용은 이제 전원이 나가도 기억하고

스왑 에어리어는 전원이 나가면 의미가없는 데이터 

전원 나가면 프로세스는 종료가 되고 메모리에 있는 내용은 사라지기떄문에

스왑에어리어는 메모리 용량의 한계라 연장 공간으로 사용

파일시스템은 비 휘발성이다.

용도가 다르기때문에 관리하는 방법도 다 다르다.

디스크랑 스토리지 관리 방법으로 후반부 에 다룰 것임 .

각 프로그램 마다 0번지  부터 시작하는 주소공간이 있는데 물리적인 메모리도 0번지부터시작하는 주소다. 

아래쪽에서 부터 쭈욱 올라가는데 프로세스 주소공간에서 0번지인데 물리공간에서 3000 ㅇ이걸 주소변환이라고하는데

주소변환 계층이 있다. 이것을 

운영체제 커널도 사실 하나의 프로그램이기때문에 코드 데이타 스택 이런식의 주소공간으로 구성이 되어있음 

운영 체제 커널에는 

시스템 콜 인터럽트를 처리하기위한 코드

자원관리를 위한 코드

편리한 서비스를 제공하기 위한 코드가있음

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/a0cf4138-46fe-405e-b47b-fc5a2b5d00cc/ad6c8ee9-62e9-44a6-ad67-5c69b9f1f1db/Untitled.png)

운영체제라는것은 각각의 인터럽트 마다 무슨 일을 처리하는것인지 를 커널 코드에 가지고있음

소프트웨어가 거는 시스템콜과 하드웨어에서 거는 인터럽트

data에는 cpu 메모리 디스크같은 하드웨어를 통제함 

그리고 운영체제는 프로세스를 관리함. (실행중인)

각 프로그램들이 독자적인 주소공간을 가지고있지만 이것을 관리하기위한 자료구조가 필요할것임 ⇒ PCB 프로세스 컨트롤 블럭 

다음에 메모리를 얼마나 줘야될지 이런것들.

함수를 호출하거나 리턴할때 stack이라는 영역을 사용해야됨 

운영체제의 코드는 여러 프로그램들이 요청에 따라서 쓸 수있음 (시스템 콜)

사용자 프로그램마다 커널스택을 따로 두고있음.

사실 모든 프로그램이 다 함수구조로 작성되어있음.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/a0cf4138-46fe-405e-b47b-fc5a2b5d00cc/fb9c83c3-98d1-4a64-bbe4-9cd41e85ea9a/Untitled.png)

어쨌든 둘 다 컴파일에서 실행파일을 만들게 되면 이 함수들이 모두 포함이 되어있음

커널함수의 호출 = 시스템 콜 

스택데이터코드안에서 점프를 하면서 호출 

커널에 함수를 호출할때는 시스템콜을 통해 인터럽트 라인을 세팅을 해서  cpu 작업을 저쪽으로 넘어가게해서 커널함수를 실행하게하는 것이다.

어떤 프로그램이 실행되는 단계를 보면 

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/a0cf4138-46fe-405e-b47b-fc5a2b5d00cc/9d08999d-5021-4fc0-ad75-7c1b28d7e447/Untitled.png)

a에서 시스템 콜 하면 kernel로 갔다가 이렇게 생긴거

a에서 쓰다가 저기갔다가 그리고 타이머 인터럽트가 들어오면 다시 갔다가 이런형태

이건 a 프로그램의 관점에서 유저모드냐 커널 모습이냐 만 보여준 그림이다.
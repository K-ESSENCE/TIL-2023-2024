## 프로세스 관리

### 프로세스가 어떻게 만들어지는가?

부모 프로세스가 자식 프로세스 생성

보통 복제생성하게 됨

프로세스의 트리 (계층 구조) 형성 => 부모가 자식낳고 낳고 그런 느낌

프로세스가 실행되려면 자원이 있어야됨 => CPU, Memory 같은것 => 이 자원은 운영체제로 부터 받고 부모랑 공유하는 경우도 아닌 경우도 있음

원칙적으로 자원을 공유하지는 않음 => 자식을 하나 낳으면 그때부터 별도의 프로세스라서 서로 cpu를 얻으려고 경쟁하는 관계가됨

프로세스가 실행될때 부모 자식이 공존하면서 실행되는 경우가 있고 자식이 종료 될때까지 부모가 기다리는 경우가있다.

프로세스의 생성은 부모가 자식을 생성하고 복제생성을한다.

복제생성?=> 부모 프로세스의 주소공간을 자식이 그대로 복사함 자식은 그 공간에 새로운 프로그램을 올림

유닉스로 예를 들면 fork() 시스템 콜이 새로운 프로세스를 생성하고 부모 복사하고 주소공간할당을 한다

fork 다음 exec() 시스템콜을 통해 새로운 프로그램을 메모리에 올린다.

독립적이기때문에 복제해놓고 덮어씌우지않을수도있다.

내가 자식 프로세스를 만들지않고 exec()을 하면 완전히 새로운 프로세스로 바뀔 수 도있다.

지금까지 살아온게 맘에안들면 다른 걸 갖다 붙여서 새로운 인생을사는게 exec()임

부모가 자식을 생성한다 말했지만 사용자 프로세스가 직접 다른 것을 생성하는게아니라 운영체제를 통해서만 가능함. 그래서 시스템콜이라 말한 것

운영체제에게 자식을 낳아달라고 부탁하는것

### 프로세스 종료

보통은 exit이라는 시스템 콜로 종료를 함

c언어로 함수를 작성했다고하면.

명시적으로 exit을 안했더라도 컴파일러가 자동으로 넣어줌

부모 프로세스가 자식의 수행을 종료시킴(abort)

부모프로세스가 자식을 종료시킴

프로세스의 세계에선 자식보다 부모가 더 오래산다.

그래서 종료될때는 자식이 부모에게 output data를 보낸다. (via wait)

자발적 종료는 exit

비자발적은 abort

강제종료되는 경우 ?

1.자식이 할당 자원의 한계치를 넘어섰을 때

2.일시켜먹을려고 자식을만드는데 자식에게 할당된 태스크가 더 이상 필요하지 않을 때

3.부모 프로세스가 종료되는 경우

자식먼저 가야되는데 부모가 종료될때 자식먼저 다죽이고 부모도 간다.

---

복제 => 프로세스의 문맥을 모두 복사하는 것

메모리 즉 주소공간을 그대로 복사해서 자식을 만든다.

cpu 문맥

cpu에서 인스트럭션을 어디까지 실행했는가 그걸 나타내는 레지스터가 프로그램카운터 pc register

프로세스가 하나 만들어지게 되면 그때부터는 독립적인 프로세스기 때문에 자원을 공유하기 때문에 부모와 자식은 서로 경쟁하면서 서로 많이 차지하려는 관계가 된다.

자식 프로세스가 부모 프로세스 걸 그대로 copy 를 하다보니 메모리 낭비가 되는 것

리눅스나 일부 모델은 모든걸 카피하지않고 공유할수있는건 가능한 공유한다. (효율적)

프로그램 카운터만 하나 카피해서 똑같은위치를 가리키다가

별개의 프로세스라서 위치가 달라졌을 경우

결국 각자의 길을 가게됨

그럼 그제서야 부모의 일부를 카피해서 자식이 받는것

이런 기법을 카피 온 라이트 라고 하는데 줄임말로 COW라고 한다.

파일시스템 같은데서 굉장히 많이나옴

뭔뜻? => write가 발생하면 그때 copy 하겠다

=> 내용이 바뀔 때 카피해서 새로 만들겠다

프로세스를 만드는건 보통일이 아니기에 os 한테 시스템콜을 통해서 만든다.

그게 fork()

포크하게 되면 부모를 그대로 복사

### fork() 시스템 콜

프로 프로세스가 fork를 하면 새로운 자식이 만들어지고 또 fork 하고 또 새로운 자식 fork 하면

fork 가 한번하면 무한하게 일어나겠네요? => fork를 하게되면 fork 가 이루어진 그 다음시점부터 자식프로세스가 실행 => 부모프로세스의문맥을 가져오기떄문 (정확히는 프로그램 카운터)

그래서 메인함수의 시작부터가아님
![Alt text](image-6.png)

그래서 어디 복제를 하러 들어가서 복제를 하게되면 애기를 낳는게 아니고 본인과 똑같이 생긴 사람이 나오게 되는 것

한가지문제? => 복제를 해놨더니 지가 원본이라고 주장하는 것

그래서 부모프로세스를 복제본 취급

세상의 프로그램들은 모두다 똑같은 제어 흐름을 따라가야될것같고 이런게 복제되었을때 생성될수있는 문제점

이런 문제를 막기위해서 복제할땐 fork라는것을 통해서 만들고 자식과 부모를 구분해줌

구분 방법? =>fork라는 함수의 리턴값이 다름

부모는 양수가 얻어짐 정확히는 자식프로세스의 pid 자식프로세스의 주민번호를 알게됨

자식프로세스는 fork의 결과값으로 0을 받음

그래서 이걸로 자기가 자식인지 부모인지를 알 수 있게 된다.

### exec() 시스템 콜

어떤 프로그램을 완전히 새로운 프로세스로 태어나게 하는 역할을 함

![Alt text](image-7.png)

execlp 는결국 exec()을 함

프로그램이 실행이되다가 exec()을 만나게되면 기억은 잊어버리고 exclp 안에있는 새로운 프로그램으로 완전히 덮어씌우는것
![Alt text](image-8.png)

한번 exec()을 하면 되돌아올수없음

프로그램 쪽에 echo라고 하는것이있음

그것은 뒤에 나올 argument를 그대로 화면에 출력해주는 c언의 printf와 유사하다.
![Alt text](image-9.png)

2는 영원히 수행이안됨

리눅스의 쉘 환경에서는

echo 3 하고 엔터치면 3이 화면이 나옴

### wait() 시스템 콜

프로세스를 잠들게 함 블럭 상태로 보냄

보통 blocked 상태는 오래걸리는 이벤트를 기다리고 이벤트가 만족되면 다시 cpu를 얻을 수 있는.

예를 들어 io 작업을 하면 block 시키듯

보통 wait 시스템콜은 자식 프로세스를 만들고 난다음에 하게됨

그렇게되면 자식상태가 종료되기를 기다리면서 블럭

자식이끝나면 부모가 다시 ready

부모 프로세스의 주소 공간 에 코드 데이터 스택으로 구성되고

병렬로 부모자식되는경우도 있지만

자식이끝날떄까지 기다리는 모델도있다.

### exit() 시스템콜

명시적으로 exit 시스템 콜 가능

전혀 사용 안했더라도 컴파일러가 {} 가 끝나면 알아서 끝내기도 함

프로세스의 종료

=> 자발적 종료 : 마지막 statement 수행후 exit()시스템 콜을 통해 끝남

=> 비자발적 종료 : 부모가 자식 프로세스를 강제 종료 시킴

자식 프로세스가 한계치를 넘어서는 자원 요청했거나
자식한테 시킨 일이 더이상 필요하지 않을때

키보드로 kill, break 등을 친 경우

부모가 종료하는 경우
부모 프로세스가 종료하기 전에 자식들이 먼저 종료됨

### 프로세스와 관련한 시스템 콜

재정리

부모를 복제하는 fork()

완전히 새로운거 exec()

자식 종료 까지 잠드는거 wait()

프로세스 종료 시키는 exit()

### 프로세스 간 협력

- 독립적 프로세스

자식 하나 만들어놓으면 코드 데이터 스택 알아서 만들어서 경쟁하면서 실행. 프로세스의 세계에서는 원칙적으로 다른 프로세스의 수행에 영향을 못 미침

(부모가 자식의 죽이는 경우외ㅇ )

- 협력 프로세스

프로세스 협력 매커니즘을 통해 하나의 프로세스가 다른 프로세스의 수행에 영향을 미칠 수 있음

- 프로세스 간 협력 메커니즘 (IPC: interprocess Communication)

대표적으로 shared memory와 message passing이 있는데

message passing 의 경우 커널을 통해 메시지를 전달하며

shared memory의 경우 서로 다른 프로세스 간에도 일부 주소 공간을 공유하게 되는 shared memory 메커니즘이 있다.

thread: 스레드는 사실상 하나의 프로세스이므로 프로세스 간 협력으로 보기에는 어렵지만 동일한 process를 구성하는 주소공간을 공유함으로 협력 가능

### Message Passing

원칙적으로 공유 변수를 일제 사용하지 않고 통신하는 시스템

다른 프로세스한테 정보를 전달할떄는 커널을 통해 메시지를 전달 함

메시지 패싱 방법은 또 두 가지

이름을 명시하느냐 안하느냐

명시하면 Direct Communication 와 Indirect Communication

어쨌든 메시지를 전달하려면 운영체제 커널을 사용해야된다는 건 둘 다 똑같다.
![Alt text](image-10.png)

원칙적으로 자기 주소공간만 볼수있는데 Shared memory는 서로 공유를 함

물리적인 메모리 제일 아래에 커널이 있고

프로세스 a ,b가 올라가있는데 a와 b가 공유하는 메모리 영역

shared memory도 커널한테 shared memory 하겠다고 시스템 콜을 하고 난 다음 사용

커널한테 우리 메모리 쉐어 할게요 하고 도움을 받은 다음.

한번 해주고난 다음부터는 사용자 프로세스 둘이서 알아서 신중하게 작업. => 잘못하면 원치 않는 결과가 나올 수 있음 한 쪽만 작업해버리면 완전 잘못되는 결과가 나올 수 있다.

여기까지가 프로세스간에 IPC를 할 수 있는 메세지패싱과 shared memory 설명

쓰레드의 경우에는 프로세스 하나에 여러개 스레드가 활동하기 때문에
완전한 협력이 가능하다.

### CPU 스케쥴링

프로그램이 실행되면

뭐든지
![Alt text](image-11.png)

이런식으로 진행이 된다.

load store add store 같은것들은 모두

CPU에서 인스트럭션을 실행하는 기계어임

이렇게 러닝을 하다가 오래걸리는 작업이 있으면 wait for I/O

CPU burst가 인스트럭션만 실행되는 단계

IO만실행되는게 IO burst

프로그램이 실행된다는건 CPU 버스트와 IO 버스트를 반복하며 실행하는 것을 말함

프로그램 종류에 따라 CPU와 IO 버스트가 빈번한게 있고 CPU만 진득하게 나오는 경우도 있고 그럼

주로 사람이 인터렉션하는게 중간중간에 서로 많이 왔다갔다 하는 프로그램
![Alt text](image-12.png)

cpu가 짧고 io 긴게 IO바운드 잡

CPU가 길다 => CPU 바운드 잡

이런것들이 섞여있음

실제로 CPU는 CPU바운드 잡이많이 쓰고

IO바운드 잡의 경우는 CPU를 많이 쓴다기보다 CPU를 짧게 쓰는데 빈도가 잦은것임

CPU 스케쥴링이 필요한 이유? => IO 바운드잡은 주로 사람과 인터랙트 하는 잡이기때문에 CPU가 CPU바운드잡에서 한번잡고 안넘겨주면 사람이 답답해짐

잡의 종류는 이런게 있지만 CPU를 가능하면 사람하고 인터렉션하게 우선적으로 주는게 CPU스케쥴링의 역할 중하나임

공평한거보다 효율적인게 더 중요함

### 프로세스 특성 분류

![Alt text](image-13.png)
IO 바운드 잡이라는건 주로 사람하고.

CPU 바운드 잡은 중간에 IO가 없기떄문에 연속적으로 사용

### CPU 스케쥴러 & Dispathcer

CPU 스케쥴러란 누구한테 줄건지 설정하는걸 CPU스케쥴러라고함

참고로 스케쥴러와 디스페쳐 둘다 하드웨어가 아니고 운영체제에 있는 역할

2 / 59:40

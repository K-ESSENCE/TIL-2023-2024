# System Structure & Program Execution 1

시스템 구조랑 프로그램 실행

Cpu 랑 메모리로 구성된것이 컴퓨터.

IO 디바이스

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/a0cf4138-46fe-405e-b47b-fc5a2b5d00cc/10db7838-883f-427f-8926-1ca0aa7a7033/Untitled.png)

메모리는 cpu의 작업공간이 메모리다.

그러니 매 사이클 마다 메모리에서 기계어를 하나씩 읽어서 실행을 하게 된다.

IO 디바이스는 그 디바이스를 전담하는 작은 cpu 같은게 붙어있는데 그게 device controller 다

cpu와 io 디바이스 성능처리속도가 다름

디스크를 cpu가 직접 관장하지않고 컨트롤러가 담당을 하는것

cpu의 운명은 메 클럭마다 메모리에서 인스럭션을 하나씩 읽어서 실행하고 그 다음 실행하고 그것만 계속함.

cpu 안에는 정보를 저장할수있는 작은 공간이있는데 이게 레지스터

cpu 안에 mode bit 이라는 게 있다.

interrupt line 이라는것도 붙어있음

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/a0cf4138-46fe-405e-b47b-fc5a2b5d00cc/07f9f617-cc28-4234-9bfd-b8394aa6206c/Untitled.png)

cpu는 항상 메모리에있는 instructio 실행하는것만 반복함

하나 실행하고 나면 다음 그다음 사이클 이런 역할 만 계속함

그러면 키보드에서 어떤 입력이 들어왔다던지 디스크에서 읽어와야 한다던지

읽어오라고 요청했는데 일을 다 끝냈다던지 하는것을 cpu 가 아는 방법 ? ⇒ interrupt line

cpu는 메모리 하고만 일한다.

키보드 입력이나 화면 출력 디스크입출력 같은게 io 디바이스

cpu는 직접 io 디바이스를 건드리지않고 메모리만.

디스크에서 뭘 읽어오라는 요청을 어떻게 보내는가? ⇒ 프로그램 a 가 디스크에서 뭘 읽어와야된다고함 → 디스크에 직접 접근 x 컨트롤러 한테 보내달라고 일을 시킴

보통은 프로그램이 쭉 메모리접근만하다가 io를 하게되면 io는 컨트롤러 한테 시키고 cpu는 놀지않고 메모리접근을 계속하게되는것

읽어온 결과물을 보고 보통은 실행하는 게 일반적인 구조.

아니면 읽은 값이 뭐냐에 따라서 무슨일을 할지가 결정

빠른속도를 이용해서 계속 일만함

그래서 프로그램이 여러 개가 켜져있으면 빠르게 동시에 처리하는것처럼 보임

문제가 있음 ⇒ 무한루프가 도는 프로그램 (계속 cpu를 쓰는 ) 얘한테 한번 넘어가면 프로그램이 종료되지않고 io를 하지도않고 계속 cpu만 쓸수도있을것임.

이렇게되면 다른 쪽으로 넘어가지못해서

타임쉐어링을 구현할수없음 (다른쪽으로 분할로 넘겨주는거 )⇒ 그래서 컴퓨터 안에는 타이머라는 하드웨어를 둔다.

타이머? ⇒ 독점을 막는다.

실행하고 라인 체크하고 이게 cpu가 반복하는 작업이다.

타이머가 interrupt를 걸어왔으면 cpu는 하던 일을 잠시프로그램으로부터 운영체제 한테 자동으로 넘어가게 되어있음

운영체제가 줄떄는 줄수있어도 뺏을수는없다. ⇒ 본인이 cpu를 가지고있으면서 실행해야 뺏던 말던 하는데 cpu를 넘겨준 다음에는 받은애가 맘대로 쓰기때문

⇒ 아무리 운영체제가 똑똑해도 뻇을수는없다.

운영체제가 cpu를 얻게되면 뭐하는가 다음 프로그램한테 넘겨줌 (타이머에 값을 세팅해서) 그러면 cpu 쓰다가 타이머 시간이 만료되면 인터럽트가 들어오면 프로그램으로부터 다시 os로 넘어가는 것

cpu의 타임 쉐어링을 구현하기 위해서 타이머라는것을 두고있음 .

본인이 직접 io 장치에 접근 ㄴ

모든건 io 장치에 접근하는건 보안 등의 이유로 운영체제를 통해서만 가능함

프로그램이 실행되다가 뭔가를 읽어오라는 요청 이 있으면 cpu가 직접하는게 아니고 늘 컨트롤러 ㄲ

23:58 그다음에 아까 그 모드 빗이라는 거는

cpu를 운영체제가 가지고있는지 프로그램이 가지고있는지 표현하는 것

modebit 0⇒ 모니터, 커널 모드 (운영체제가 cpu에서 수행중일때)

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/a0cf4138-46fe-405e-b47b-fc5a2b5d00cc/b133df55-4739-4748-bac2-bed5a4b314ec/Untitled.png)

운영체제가 cpu에서 실행중일때는 메모리접근 뿐만아니라 io 디바이스 접근 등을 다 실행 할 수 있게끔 되어있음 .

사용자 프로그램은 다쁜 짓을 할 수 있기때문에 그걸 못하게 하려면 mode bit 을 통한 보호가 필요하다.

모니터모드 = 커널 모드 = 시스템 모드

보호와 보안을 목적으로 지침 설정을 나누어놓았다는 이야기

타이머 : 특정 프로그램이 cpu 독점하는것을 막기위해 넘겨줄때에는 정해진 시간 을 할당하고 넘겨줌

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/a0cf4138-46fe-405e-b47b-fc5a2b5d00cc/fff13215-259e-4659-b20a-c3333db1061e/Untitled.png)

Device Controller

I/O device controller

데이터 자체는 로컬 버퍼에 놓고 저장하라는 명령은 제어 레지스터를 통해서

메모리를 원칙적으로는 CPU만 접근할 수 있게 해놓은것

IO디바이스는 자기자신만의 로컬 버퍼가있기때문에 버퍼

버퍼에다가 데이터를 받아 일을하고 버퍼에 쌓이게되면 cpu가 내용을 읽어서 자신의 작업영역인 메모리에 복사를 함 .

cpu는 메모리 접근도 되고 로컬 버퍼 접근도 할 수 있게끔 되어있음

작은 cpu들은 자기 로컬 버퍼에만 접근 할 수 있고

근데 이렇게하다보니 너무나도 interrupt를 많이 당한다.

어떤 장치는 인풋하나 걸면 데이터 카피.

뭐 좀할려고하면 또 키보드입력 interrupt 카피

이렇게 너무많이 인터럽트를 당하면 효율적으로 동작하지 않는다.

그래서 DMA 컨트롤러를 가지고있다

디렉트메모리 엑세스

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/a0cf4138-46fe-405e-b47b-fc5a2b5d00cc/e1bef01d-803b-4ebe-ab26-bbdc35958753/Untitled.png)

직접 메모리에 접근할 수 있는 컨트롤러

둘이서 동시에 메모리에 접근할때 문제가 생길수있어서 DMA 가 그걸 중재함 ⇒ 누가 먼저 접근하게 할지 조율함

왜 달아놓았는가? ⇒ IO 장치가 너무 자주 거니까 cpu 방해를 너무 많이 받음. 그걸 막기위한 DMA 컨트롤러 .

cpu는 계속 자기일 을 하고있고 . 중간에 들어오는 로컬 버퍼의 내용이 끝나면 DMA가 직접 메모리로 복사까지 해줌.

그 작업이 다끝나면 cpu한테 인터럽트를 한번만 건다.

그러면 cpu는 중간에 인터럽트 당하는 빈도가 줄어들어 효율적으로 쓸 수 있다.

device driver = 소프트웨어 (구동기)

os 코드 중 각 장치별 처리루틴

device controller = 하드웨어임

각 장치를 통제하는 작은 cpu (각디바이스 마다 전담하는 작은 cpu )

하드웨어를 하나 붙이면 거기 접근하기위한 것을 하나 붙이는 것

지침 중에서 io 장치 를 접근해야되는 상황이 되면 device 드라이버를 통해 읽고쓰라는 명령을 하게 됨

device 드라이버가 직접 헤드를 움직여서 하는건 아님 .

cpu는 직접일하는게아니고 메모리의 지시를 받아 일을 함

디바이스 드라이버도 일을 하기위해서는 메뉴얼이 필요함.

디스크안의 펌웨어 (디스크를 동작하기위해서는 뭘해야되는지 그 코드)

디바이스 드라이버⇒ cpu가 실행하는 것을 수행하기 위해서 필요한 코드를 담고있는것

메뉴얼대로일하고 메뉴얼에 적혀있는것은 메모리 몇번지에 있는 일을 하라는지 적혀있고 그일을하면됨

### 입출력의 수행

입출력의 명령은 modebit의 모니터링 에서 실행되는 특권 명령이 필요함.

사용자 프로그램은 io를 어떻게 하는가? ⇒

운영체제에게 부탁을함 이걸 시스템 콜이라고함 ( 사용자 프로그램이 부탁하는것 )

일반 함수 호출과는 조금 다름 ⇒

cpu에서 인스트럭션을 수행하다가 제어문을 만나게 되면 순차적으로 실행하다가 메모리위치를 점프한다.

반복문 같은거

내 프로그램안에서 함수호출 하는건 그 안에서 메모리 주소를 바꾸는 것인데 내 프로그램이 실행되다가 io 요청을 하기 위해서 운영체제 함수를 호출하는것 이 시스템 콜 이건 좀 더 복잡하다.

이프로그램이 cpu를 가지고있으면 인스트럭션을 쭉 실행을 하고 하나가 실행되고 나면 인터럽트를 체크하는데

타이머가 걸거나 io 컨트롤러가 거는게 아니고 프로그램이 운영체제에게 뭔가를 요청하기위해서 소프트웨어적으로 직접 인터럽트를 걸 수 있다.

그러면 cpu는 이 프로그램의 다음 지침이 아니라 interrupt가들어왔기떄문에 modebit 이 0 으로

그럼 시스템 콜을 하면 운영체제가 cpu를 가지고있고 디스크 컨트롤러 한테 부탁을한다.

인터럽트는 하드웨어 일꾼들이 cpu한테 뭔가 정보교신을 할려고 걸수도있고 사용자프로그램이 돌아가다가 직접 처리 못하고 운영체제한테 부탁하는 상황에서도 인터럽트라인을 세팅할수도있다.

소프트웨어가 인터렙트를 거는 = 트렙

일반적으로 걸면 ⇒ 하드웨어가 인터럽트를 거는것을 말함

넓은의미의 인터럽트 ⇒ 소프트 + 하드웨어

os는 항상 올바른 요청인지 확인한다.

io디바이스에 접근 권한이 있는건지. 올바른 요청인 경우에 i/o 요청을 부탁하게 된다.

io를 하기위한 인터럽트가 두가지 종류가 걸림

사용자 프로그램이 io 요청을 위한 시스템 콜을 걸음 ⇒ 소프트웨어 인터럽트

인터럽트 벡터라는게있고 인터럽트 처리 루틴이라는 게 있다.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/a0cf4138-46fe-405e-b47b-fc5a2b5d00cc/d2231597-3911-4337-9d0f-51dd321505b5/Untitled.png)

인터럽트를 처리하는게 처리루틴

어디로 가고 어디로가고 이런걸 표시하는게 벡터 에 표시를 한다 .

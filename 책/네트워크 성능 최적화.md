## TCP의 구성요소 

TCP는 신뢰할 수 없는 채널 위에 신뢰성을 구축한 추상 계층이다.
네트워크 통신 구현에 필요한 유실 데이터 재전송, 전송 순서 확인, 혼잡 제어 및 회피 데이터 무결성 확인 같은 복잡한 기능을 투명하게 처리하여 어플리케이션 구현을 한결 쉽게 만들어준다.

TCP스트림의 특징 중하나는 전송된 모든 바이트는 수신된 모든 바이트와 한 치의 오차 없이 동일하며, 클라이언트에서 전송된 바이트 순서대로 도착한다는것.

TCP는 신속한 데이터 전송보다 <b>정확한 데이터의 전송에 더 특화되어있다.</b>

이때문에 웹 성능을 최적화하는데에 어느정도 문제를 야기하기도함.

HTTP 표준은 전송 프로토콜로서 오직 TCP만을 명시하고 있지는 않음. 
HTTP를 유저 데이터 그램 소켓 (UDP)나 우리가 원하는 다른 어떤 프로토콜을 사용해도됨. 

그러나 실제 오늘날 모든 HTTP 트래핏은 전부 TCP를 통해 전송.

TCP자체적으로 훌룡한 기능들이 많아서 ㅇ

이런 연유로 TCP의 핵심 매커님즘을 이해하는것이 웹 성능을 최적화 하는데에 필수적임.
직접적으로 TCP소켓을 다룰일은 거의 없겠지만 애플리케이션 계층에서 선택하는 설계방법에 따라 TCP와 기본적인 네트워크성능이 결정됨.


### 3Way 핸드셰이크
모든 TCP연결은 3-Way 핸드셰이크로부터 시작된다. 

클라이언트와 서버가 애플리케이션 데이터를 주고받으려면 먼저 시작 패킷의 시퀸스 번호와 현재 연결과 관련된 여러 변수의 값을 상호 합의해야함

순서번호는 보안상이유로 양쪽에서 무작위로뽑음.

- SYC
  클라이언트가 무작위로 시퀸스 번호x를 고르고 SYN패킷을 보냄 그밖의 다른 옵션 포함 가능
  다른 TCP플래그나 옵션값들을 포함가능  

- SYN ACK
  서버가 시퀸스 번호 x를 증가시키고 무작위로 y번호를 고름
  서버역시 다른 옵션 추가 가능


- ACK
  클라이언트가 x와 y 값 모두 1씩 증가시키고 마지막 ACK패킷을 보냄으로써 핸드셰이크 종료 


3Way 핸드셰이크가 끝나면 애플리케이션 데이터가 클라와 서버 사이에 오고갈 수 있게됨. 
ACK패킷뒤에 바로 데이터 패킷을 보낼 수 있고 서버는 ACK패킷이 도착해야만 패킷을 보낼 수 있다.

초기절차는 모두 TCP연결에 해당되며 , TCP이용하는 모든 네트워크 애플리케이션의 성능에 중요한 영향을 미침
새로 맺어지는 모든 커넥션은 데이터가 전송되기도전에 클라와 서버간에 왕복레이턴시를 한번 겪게됨.

중요한건 대역폭의 크기는 소요되는 시간에 아무런 영향을 미치지 않는다는것임.

대신에 지연되는 시간은 모두 클라이언트와 서버간의 레이턴시에 의해 발생하며 그 레이턴시는 <b>뉴욕과 런던 사이에 발생하는 전파시간에 의해 정해진다</b>
3-way 핸드셰이크로 인해 발생하는 지연이 크기 때문에, 새로운 TCP커넥션을 맺는 것보다 기존에 연결되어있는 TCP커넥션을 재사용하는것이 TCP에서 작동하는 앱의 최적화에 아주 중요함


- TCP Fast Open

TCP 핸드셰이크는 웹 브라우징 레이턴시의 주된이유. 
여러 호스트로부터 수십개 에서 수백개의 리소스를 얻어오기 위해 짧은 TCP플로가 빈번하게 발생하기 때문 
TCP FAST Open (TFO)은 새로운 TCP 커넥션을 생설할 때마다 발생하는 레이턴시 문젤를 최소화하기 위해 만들어지 메커니즘임.


TFO는 SYN 패킷 안에서 데이터 전송을 가능하게 함으로써 HTTP 트랜잭션 네트워크 레이턴ㅇ시를 15% 만큼 줄였고 전체 페이지로딩 시간은 10% 만큼 레이턴시가 높은 몇몇은 40%까지도 줄일수 있었음.

Linux 3.7+ 커널에서는 서버와 클라이언트 모두 TFO를 지원하고 있으므로 새로운 클라이언트와 서버에게는 좋은 옵션이 될 수있다. 
하지만 TFO 역시 모든 문제를 해결 할 수 있는것은 아님 <b>왕복 패널티 를 줄이는데에는 유용</b>하지만, __특정 조건이 충족되어야만 사용가능__

SYN 패킷 내에는 데이터 페이로드의 크기에 한계가 있기 때문에 특정 타입의 HTTP 요청만 전송할 수 있으며, 암호화된 쿠키를 필요로 하기 떄문에 반복적으로 커넥션을 맺을 때 활용할 수 있다. 


### 혼잡 제어 및 회피 

혼잡 붕괴는 대역폭이 서로 다른 채널로 구성된 네트워크에 영향을 주는 현상이다. 
복잡한 네트워크에서 으레 존재하는 문제임

데이터그램, 프로토콜  그리고 TCP 전송 계층 프로토콜을 함께 사용할 때 이 전송 계층과 데이터그램 계층 간의 상호 작용에 의해 혼잡이 발생한다는것을 발견됨

특히 IP게이트웨이는 소위 말하는 "혼잡 붕괴" 라는 현상에 노출되어있는데 이러한 현상은 __게이트웨이가 갖가지 다른 대역폭을 가진 네트워크와 연결되었을때__ 특히 더 자주 발생한다. 

어떤 호스트의 왕복 시간이 최대 재전송 시간 간격을 초과하게 되면 그 호스트는 네트워크에 지속적으로 같은 데이터그램의 복사본을 보내게됨. => 네트워크에 심각한 문제가 생기게됨

스위칭 노드에 있는 모든 버퍼가 꽉 차게되고 패킷들은 버려질 수 밖에 없게됨. => 도착하는 패킷의 왕복 시간은 최대치까지 올라감

__호스트는 같은 패킷을 여러 번 보내게 되고, 결국은 같은 패킷의 여러 복사점이 도착점에 도착하게됨.__  

이것이 혼잡붕괴.. 


이런 상태는 꽤나 지속되기 때문에, 일단 네트워크가 포화상태에 이르고 나면 버릴 패킷을 고르는 알고리즘이 평이하다는 전제하에 네트워크는 계속해서
_열악한 환경에서 동작하게 된다_


이러한 문제를 해결 하기 위해, 양방향으로 데이터를 보내는 속도를 조절할 수 있는 여러 가지 메커니즘이 TCP에 도입.
그것이 바로 흐름 제어 , 혼잡 제어 그리고 혼잡 회피이다. 

### 흐름제어 (Flow Control)


## TCP의 구성요소 

TCP는 신뢰할 수 없는 채널 위에 신뢰성을 구축한 추상 계층이다.
네트워크 통신 구현에 필요한 유실 데이터 재전송, 전송 순서 확인, 혼잡 제어 및 회피 데이터 무결성 확인 같은 복잡한 기능을 투명하게 처리하여 어플리케이션 구현을 한결 쉽게 만들어준다.

TCP스트림의 특징 중하나는 전송된 모든 바이트는 수신된 모든 바이트와 한 치의 오차 없이 동일하며, 클라이언트에서 전송된 바이트 순서대로 도착한다는것.

TCP는 신속한 데이터 전송보다 <b>정확한 데이터의 전송에 더 특화되어있다.</b>

이때문에 웹 성능을 최적화하는데에 어느정도 문제를 야기하기도함.

HTTP 표준은 전송 프로토콜로서 오직 TCP만을 명시하고 있지는 않음. 
HTTP를 유저 데이터 그램 소켓 (UDP)나 우리가 원하는 다른 어떤 프로토콜을 사용해도됨. 

그러나 실제 오늘날 모든 HTTP 트래핏은 전부 TCP를 통해 전송.

TCP자체적으로 훌룡한 기능들이 많아서 ㅇ

이런 연유로 TCP의 핵심 매커님즘을 이해하는것이 웹 성능을 최적화 하는데에 필수적임.
직접적으로 TCP소켓을 다룰일은 거의 없겠지만 애플리케이션 계층에서 선택하는 설계방법에 따라 TCP와 기본적인 네트워크성능이 결정됨.


### 3Way 핸드셰이크
모든 TCP연결은 3-Way 핸드셰이크로부터 시작된다. 

클라이언트와 서버가 애플리케이션 데이터를 주고받으려면 먼저 시작 패킷의 시퀸스 번호와 현재 연결과 관련된 여러 변수의 값을 상호 합의해야함

순서번호는 보안상이유로 양쪽에서 무작위로뽑음.

- SYC
  클라이언트가 무작위로 시퀸스 번호x를 고르고 SYN패킷을 보냄 그밖의 다른 옵션 포함 가능
  다른 TCP플래그나 옵션값들을 포함가능  

- SYN ACK
  서버가 시퀸스 번호 x를 증가시키고 무작위로 y번호를 고름
  서버역시 다른 옵션 추가 가능


- ACK
  클라이언트가 x와 y 값 모두 1씩 증가시키고 마지막 ACK패킷을 보냄으로써 핸드셰이크 종료 


3Way 핸드셰이크가 끝나면 애플리케이션 데이터가 클라와 서버 사이에 오고갈 수 있게됨. 
ACK패킷뒤에 바로 데이터 패킷을 보낼 수 있고 서버는 ACK패킷이 도착해야만 패킷을 보낼 수 있다.

초기절차는 모두 TCP연결에 해당되며 , TCP이용하는 모든 네트워크 애플리케이션의 성능에 중요한 영향을 미침
새로 맺어지는 모든 커넥션은 데이터가 전송되기도전에 클라와 서버간에 왕복레이턴시를 한번 겪게됨.

중요한건 대역폭의 크기는 소요되는 시간에 아무런 영향을 미치지 않는다는것임.

대신에 지연되는 시간은 모두 클라이언트와 서버간의 레이턴시에 의해 발생하며 그 레이턴시는 <b>뉴욕과 런던 사이에 발생하는 전파시간에 의해 정해진다</b>
3-way 핸드셰이크로 인해 발생하는 지연이 크기 때문에, 새로운 TCP커넥션을 맺는 것보다 기존에 연결되어있는 TCP커넥션을 재사용하는것이 TCP에서 작동하는 앱의 최적화에 아주 중요함


- TCP Fast Open

TCP 핸드셰이크는 웹 브라우징 레이턴시의 주된이유. 
여러 호스트로부터 수십개 에서 수백개의 리소스를 얻어오기 위해 짧은 TCP플로가 빈번하게 발생하기 때문 
TCP FAST Open (TFO)은 새로운 TCP 커넥션을 생설할 때마다 발생하는 레이턴시 문젤를 최소화하기 위해 만들어지 메커니즘임.


TFO는 SYN 패킷 안에서 데이터 전송을 가능하게 함으로써 HTTP 트랜잭션 네트워크 레이턴ㅇ시를 15% 만큼 줄였고 전체 페이지로딩 시간은 10% 만큼 레이턴시가 높은 몇몇은 40%까지도 줄일수 있었음.

Linux 3.7+ 커널에서는 서버와 클라이언트 모두 TFO를 지원하고 있으므로 새로운 클라이언트와 서버에게는 좋은 옵션이 될 수있다. 
하지만 TFO 역시 모든 문제를 해결 할 수 있는것은 아님 <b>왕복 패널티 를 줄이는데에는 유용</b>하지만, __특정 조건이 충족되어야만 사용가능__

SYN 패킷 내에는 데이터 페이로드의 크기에 한계가 있기 때문에 특정 타입의 HTTP 요청만 전송할 수 있으며, 암호화된 쿠키를 필요로 하기 떄문에 반복적으로 커넥션을 맺을 때 활용할 수 있다. 


### 혼잡 제어 및 회피 

혼잡 붕괴는 대역폭이 서로 다른 채널로 구성된 네트워크에 영향을 주는 현상이다. 
복잡한 네트워크에서 으레 존재하는 문제임

데이터그램, 프로토콜  그리고 TCP 전송 계층 프로토콜을 함께 사용할 때 이 전송 계층과 데이터그램 계층 간의 상호 작용에 의해 혼잡이 발생한다는것을 발견됨

특히 IP게이트웨이는 소위 말하는 "혼잡 붕괴" 라는 현상에 노출되어있는데 이러한 현상은 __게이트웨이가 갖가지 다른 대역폭을 가진 네트워크와 연결되었을때__ 특히 더 자주 발생한다. 

어떤 호스트의 왕복 시간이 최대 재전송 시간 간격을 초과하게 되면 그 호스트는 네트워크에 지속적으로 같은 데이터그램의 복사본을 보내게됨. => 네트워크에 심각한 문제가 생기게됨

스위칭 노드에 있는 모든 버퍼가 꽉 차게되고 패킷들은 버려질 수 밖에 없게됨. => 도착하는 패킷의 왕복 시간은 최대치까지 올라감

__호스트는 같은 패킷을 여러 번 보내게 되고, 결국은 같은 패킷의 여러 복사점이 도착점에 도착하게됨.__  

이것이 혼잡붕괴.. 


이런 상태는 꽤나 지속되기 때문에, 일단 네트워크가 포화상태에 이르고 나면 버릴 패킷을 고르는 알고리즘이 평이하다는 전제하에 네트워크는 계속해서
_열악한 환경에서 동작하게 된다_


이러한 문제를 해결 하기 위해, 양방향으로 데이터를 보내는 속도를 조절할 수 있는 여러 가지 메커니즘이 TCP에 도입.
그것이 바로 흐름 제어 , 혼잡 제어 그리고 혼잡 회피이다. 

### 흐름제어 (Flow Control)

흐름제어는 송신자가 수신자에게 처리하지 못할 만큼의 많은 데이터를 전송하는 것을 미리 방지하는 메커니즘 
수신자가 데이터를 받짐 못하는 경우 보통 수신자가 다른 데이터를 처리하고 있거나 , 말려있는 데이터가 많거나, 버퍼공간을 충분히 지정해 주지 않는 경우다. 

문제해결을 위해 양쪽의 TCP 커넥션이 각각자신의 리시브 윈도 (rwnd)를 통지하여 수신 데이터를 저장할 버퍼 공간의 크기를 서로에게 알려줌
커넥션이 이루어지면 양쪽에서 자신들의 시스템 기본 설정값 이용하여 rwnd값 초기화. 

일반적으로 웹페이지는 서버에서 클라이언트 쪽으로 대부분의 데이터를 스트리밍 하기 때문에 병목지점이 되는 곳은 클라이언트 쪽일 가능성이 높다. 
하지만 클라이언트가  이미지나 동영상 업로드로 많은 데이터를 서버에게 스트리밍하고있다면 이때에는 서버의 리시브 윈도가 병목지점이 될 것이다. 

어떤 이유로든 서버와 클라중 한곳에서 __수신하고있는 데이터의 양을 감당하지 못할 경우__에는 송신자에게 __리시브 윈도의 크기를 예전보다 줄여 재통지가능__. 

윈도의 크기가 0에 다다르면 현재 버퍼에 남아있는 데이터가 모두 애플리케이션 계층에서 처리될 때까지 새로운 데이터를 수신할 수 없다고 표시됨. 

이러한 작업의 흐름은 모든 TCP 커넥션이 시작할 때부터 끝날 때까지 계속된다. 모든 ACK패킷은 양 끝단의 가장 최근 윈도 크기 (rwnd)
값을 담고있음 . 양(책에서는 야 라고 적혀있는데 오타인듯) 끝의 노드는 이 값을 참고해서 송신자와 수신자의 처리 용량과 성능을 유추해내고 이를 고려해 전송할 데이터양을 유동적으로 조절 가능 => __rwnd값을 참고해서 처리용량과 성능 유추 후 유동적으로 데이터양 조절가능__

- 윈도 스케일링 
원래의 TCP 스펙에서는 리시브 윈도 사이즈를 지정할때 16비트를 할당함. 이것은 __송신자와 수신자가 지정할 수 있는 크기의 최대치가 정해져있__다는 이야기

그런데 실상 이 최대치가 최적의 성능을 내기 위해서는 종종 충분치 않음. 특히 대역폭 지연 곱(bandwidth delay product)이 높은 네트워크에서는 더더욱 그렇다. 

이 문제를 해결하기위해 "TCP 윈도 스케일링" 옵션을 제공하는 RFC 1323이 기술됨.  
이 옵션은 655353 바이트 에서 1기가 바이트까지 늘릴 수 있게 해줌.  이 옵션은 3-Way 핸드셰이크가 일어나는 과정 중에 교환되며 이 옵션이 가지고 있는 값은 차후 ACK에 포함될 16비트 윈도 크기 필드값에 왼쪽 시프트 연산을 해야 할 비트 수를 나타냄.

__오늘날 TCP 윈도 스케일링 옵션은 대부분의 플랫폼에서 기본적으로 활성화 되어있음__ 하지만 중간 노드 , 라우터 , 방화벽 등이 이 설정된 옵션을 다른 값으로 덮어쓰거나 아예 제거 해버릴 수도 있다.  당신이 서버나 클라이언트와 연결을 할 때 허용된 대역폭을 모두 활용할 수 없는 상황이라면 윈도 크기에 대한 정보가 제대로 오가고 있는지 확인할 필요가 있다. 

리눅스 플랫폼에서는 다음의 명령어를 이용하여 윈도 스케일링 옵션을 확인하고 활성화시킬 수 있음

```
$> sysctl net.ipv4. tcp_window_scalling
$> sysctl -w net.ipv4.tcp_window_scalling=1
```

### 느린 시작 

TCP 내에 흐름 제어가 있음에도 불구하고 네트워크 혼잡 붕괴는 1980년 후반에 현실적인 문제로 다가왔다. 

흐름 제어는 송신자가 수신자에게 부담을 주지 않도록 하는 기능을 하고 있었으나, 네트워크 자체에 주는 부담을 막는 메커니즘은 존재하지않았다. 
흐름 제어는 송신자나 수신자 모두 새로운 커넥션이 생성될 때 허용된 대역폭이 얼마 만큼인지 알지 못하기 때문에 ,수시로 변화하는 네트워크 상태에 따라 대역폭을 가늠하고 그에 따라 데이터의 전송속도를 조절하는 메커니즘이 필요했다. 

예를 들어 집에서 원격 서버로부터 대용량의 동영상을 스트리밍한다고 가정할때 그 비디오 스트리밍이 다운링크를 완전히 점유하고있는 상태다.
그런데 홈 네트워크 안에서 또 다른 사용자가 새로운 커넥션을 만들고 소프트웨어를 다운로드하기 시작. 

갑자기 비디오 스트림에게 주어진 다운로드 대역폭이 급격히 줄어들었기 때문에 비디오 서버는 변화된 상황에 따라 데이터 전송률을 조절해야만 한다. 

전송률을 조절하지 않는다면 데이터는 중간에 있는 게이트웨이에서 점점 쌓이게 되고 결국 패킷이 누락되게 되면서 네트워크를 효율적으로 사용할 수 없게 된다.
=> 전송률을 조절하지않으면 쌓이고 패킷이 누락되서 비효율적이된다.

이 문제를 해결하기위한 알고리즘이 느리신작, 혼잡회피, 빠른 재전송, 빠른 복사이다.

이 네가지 알고리즘이 신속하게 TCP 스펙의 필수적인 부분으로 자리 잡았다. 

실제로 이 알고리즘 덕택에 80 90 년대 초에 인터넷 붕괴를 막았다고 믿는 사람들도 있음.


느린 시작을 이해하기 위해서는 이것이 실제로 동작하는 것을 보는게 제일 좋다. 
고객이 런던의 서버에서 파일을 다운로드 하기 위해 접속 => 3-Way 핸드 셰이크 발생. 이때 클라이언트와 서버 모두 자신들의 리시브 윈도(rwnd)크기를 ACK패킷에 실어 서로에게 통지. 마지막 ACK패킷이 출발하고 나면 그때부터 우리는 데이터를 주고 받을 수 있음.

__클라와 서버간의 허용량을 가늠하는 유일한 방법은 실제로 데이터를 교환하면서 허용량을 측정하는 것뿐이다.__ __이게 느린 서버가 하는 일이다.__

일단 서버가 각 TCP 커넥션 마다 새 혼잡 윈도(cwnd) 변수를 만들고 그 값을 시스템에서 정해진 안전한 수치로 설정한다. 

- 혼잡 윈도 크기 (cwnd)
  클라이언트로부터 응답 확인(ACK)신호를 받기 전에 송신자 측에서 지정하는 최대 송신 데이터량.

  cwnd 변수는 송신자와 수신자 간에 값이 교환되거나 서로 통지되지 않는다. 이 경우 cwnd 변수는 서버에서만 private 변수로 관리된다.
  더 나아가 새로운 규칙이 적용되는데. ACK신호를 받지않는 송신자와 수신자 사이에서 이동중인 데이터의 최대치는 rwnd와cwnd 값중 작은 값이 된다.

서버와 클라이언트는 네트워크 상태가 같은 노드에서 항상 변화하는데 어떻게 혼잡 윈도 크기의 최적값을 알아내는 것일까?
매 커넥션 마다 수동으로 윈도 사이즈를 조정하지 않고 어떠한 알고리즘을 사용할 수 있다면 정말 좋을것임.

__문제의 해결법은 커넥션 초반에는 천천히 시작해서 ACK 패킷을 받으면서 점점 윈도 사이즈를 늘려 나가는 것임.__ 이것이 바로 느린 시작
본래 cwnd의 초기값은 1 네트워크 세그먼트로 정해져 있었다.  RFC 2581 에서 이값을 4로 늘렸고 RFC 6928에서 10세그먼트로 다시값을 증가시켰음.

새 TCP 커넥션에서 이동중인 데이터의 최대치는 rwnd와 cwnd의 최소값으로 정해져있음. 그러므로 서버는 클라이언트에게 최대 4개의 세그먼트를 보낼 수 있고, 그 후에는 ACK 신호를 기다려야만 한다.  그러고 나서는 ACK 신호를 받을 때마다 느린 시작 알고리즘이 서버의 cwnd윈도 사이즈를 1 세그만트 만큼 증가시킴. 그 후에는 ACK 신호를 기다려야만 함.  ACK 신호를 받을 때마다 느린 시작 알고리즘이 서버의 cwnd윈도 사이즈를 1세그먼트 만큼 증가시킴. ACK를 받은 패킷 하나당, 두 개의 새로운 패킷을 더 보낼 수 있는것임. 

TCP커넥션에서 이는 보통 __기하급수적 성장 알고리즘__ 으로 알려져 있음. 클라이언트와 서버가 그들 사이의 네트워크에서 사용가능한 대역폭에 신속히 도달하려 하기때문

브라우저 애플리케이션을 개발할 때에 느린 시작(slow-start)을 중요하게 고려해야 할 이유는 무엇일까? __그것은 TCP상에서 동작하는 HTTP나 다른 애플리케이션 프로토콜들은 주어진 대역폭과 관계없이 무조건 이 느린 시작을 거쳐야되기 때문__

모든 TCP 커넥션에서 우리는 곧바로 링크의 최대 허용량을 활용할 수 가없음.

대신 작은 혼잡 윈도 크기부터 시작해서 매번 왕복할때마다 윈도 사이즈를 두 배씩 늘려나가는것이다. 
그 결과 클라와 서버사이의 왕복시간(RTT)과 초기 혼잡 윈도 크기를 이용한 방정식으로 부터 얻을 수 있음.

TCP 커넥션의 초기 처리량은 혼잡윈도 값에 의해 제한되어있고 이는 처리량에 도달하기위해 데이터가 왕복하고 수백초의 레이턴시를 겪어야한다는 뜻으로 클라와 서버가 Mbps이상으로 데이터를 전송할 수 있는 네트워크 성능을 갖췄다 해도 아무소용이없음. 

이게 느린 시작.

혼잡 윈도 크기를 증가시큰데 걸리는 시간을 단축시키기 위해서는 클라이언트와 서버 간의 왕복 시간을 줄이는 방법이 있다.
예를 들어 서버의 위치를 클라이언트에 보다 지역적으로 가까운 곳에 배치시킨다든지. 
혹은 초기 혼잡 윈도 크기 값을 새 RFC 6928에 정의한 10 세그먼트로 늘릴 수도 있음.

느린 시작은 대용량 데이터를 스트리밍하는데에는 큰 영향을 미치지 않는다. 클라이언트와 서버가 단 수백 밀리초 후에 거의 최대 속도로 데이터를 전송할 수 있기 때문.

느린 시작이 미치는 영향은 전송하는 데이터가 클수록 미미해짐.
하지만 대부분의 HTTP 커넥션이 그렇듯, 연결이 짧고 일시적인 경우가 많기 때문에 최대 윈도 크기에 도달하기도 전에 요청이 끝나버리는 일이 발생한다. 

결과적으로 많은 웹 어플리케이션의 성능은 종종 서버와 클라이언트 간의 왕복 시간에 제한되는 경우가 있다.  느린 시작이 최대로 사용할 수 있는 대역폭에 제한을 둠으로써 용량이 작은 데이터를 전송하는 데에는 부작용으로 다가온다. 

- 느린 시작 다시 시작하기
새 커넥션에서 데이터 전송률에 제한을 두는 것 말고도 TCP의 커넥션이 일정시간 동안 유휴 상태(idle)에 머물러 있으면 혼잡 윈도 값을 초기화하는 slow-start-restart(SSR)라는 매커니즘이 존재한다. SSR의 논리는 간단하다. 커넥션이 유휴 상태에 들어가있는동안 네트워크가 어떻게 변해있을지 모르기때문에 , 혼잡을 피하기위해 윈도가 '안전한' 기본값으로 초기화 되는 것이다.
SSR은 여러 번 연달아 유휴 상태에 돌입하는 수명이 긴 TCP 커넥션(long-lived-TCP)에 심각한 영향을 끼칠 수 있다.
HTTP 킵얼라이브(keepalive) 커넥션이 좋은 예다. 결과적으로 서버 측에서 SSR을 비활성화시키는 것이 바람직하다. 리눅스 플랫폼에서는 다음 명령어를 이용하여 SSR의 값을 확인하고 비활성화시킬 수 있다.

```
$> sysctl net.ipv4.tcp_slow_start_after_idle
$> sysctl -w net.ipv4.tcp_slow_start_after_idle=0

```


3-Way 핸드셰이크와 느린 시작 과정이 단순한 HTTP 전송에 끼치는 영향을 좀 더 자세히 들여다 보자.

왕복시간 
클라이언트와 서버사이의 대역폭
클라이언트와 서버 리시브 윈도 
초기 혼잡 윈도
서버 측에서 응답신호를 생성하기 위한 처리시간
패킷 손실 없고, 패킷당 ACK,GET요청이 단일 세그먼트에 들어맞음

<순서>
클라가 SYN 보내고 TCP핸드셰이크 시작
서버가 SYN-ACK로 응답 하고 rwnd 크기 지정
클라가 SYN-ACK에 ACK을 보내고 rwnd 크기를 지정한 후 곧바로 HTTP GET요청
서버가 HTTP 요청을 받음
서버가 응답을 생성한 후 4개의 TCP세그먼트를 보내고 ACK 신호가 오길 기다림 (초기 cwnd 크기는 4다)
클라이언트가 4개의 세그먼트를 받고 각 세그먼트마다 ACK를 보낸다.
서버가 각 ACK마다 cwnd값을 1씩 올리고 8개의 세그먼트를 보낸다
클라가 8개 받고 각 세그먼트마다 ACK 보낸다.
서버각 각 ACK 마다 cwnd값을 1 올리고 나머지 세그먼트를 보낸다.
클라가 나머지 받고 세그먼트 마다 ACK를 보낸다.

연습삼아 cwnd를 4대신 10으로 하면 한번의 왕복시간만큼 레이턴시가 감소하는것을 볼 수 있다 => 성능의 22% 향상으로 볼 수 있음

만약 클라이언트가 기존 TCP 커넥션을 재사용할 수 있었다고 가정하고 한번 더 요청하게되면 3-Way핸드셰이크와 느린 시작 구간의 패널티가 없어졌기 때문에 모든 과정이 275%의 성능향상으로 볼 수 있게된다. 

서버와 클라가 5Mbps의 업스트림의 대역폭을 가졌다는 점에서 TCP 커넥션에서는 아무런 영향을 끼치지않았다. 
그대신 레이턴시와 혼잡 윈도 크기가 주된 제한 요인이였음 .

왕복 시간을 늘릴 수록 두 경우의 성능 차이는 점점 더 벌어짐.
연습삼아 몇 가지 다른 수치록도 시험해봐라 TCP 혼잡 제어의 매너키즘에 대해 감을 잡을 수있도록 킵얼라이브, 파이프라인, 멀티플렉싱과 같은 여러 최적화 방식을 사용하는것이 점점더 꺼려질 수도 있음.

- TCP의 초기 혼잡 윈도 크기 증가

TCP를 사용하는 모든 애플리케이션의 성능을 함께 개선하는 가장 쉬운 방법은 새로운 RFC 6928의 제안대로 서버의 초기 cwnd 크기를 10 세그먼트로 키우는 것이다. 다행히도 많은 운영체제가 증가된 값을 사용하기 위해서 이미 최신 커널로 업데이트를 마쳤다는 사실이다.

여러 문서와 릴리스 노트들을 확인해 보면 알 수 있다.

리눅에서저는 IW 10 이 커널 2.6.39 이상부터는 기본값으로 사용되고 있다. 하지만 여기서 멈추지 말자. 버전 3.2 이상으로 업그레이드 하면 그 밖에 다른 중요한 업데이트의 혜택을 얻을 수 있다. 

### 혼잡 회피 

TCP는 자체 성능을 조절하기 위한 피드백 매커니즘으로써 패킷 손실을 이용하도록 설계되었다는 사실을 인지해야 한다. 
다르게 말하면 패킷 손실이 일어나지 않는 경우는 없고 그보다 패킷 손실이 언제 발생하는가를 파악하는것이 더 중요하다. 
느린 시작(slow-start)은 작은 윈도 크기로 커넥션을 시작한 후, 데이터가 한 바퀴 왕복할 때마다 한 번에 이동하는 데이터 양은 두배로늘어난다.
이 과정은 이동하는 데이터 양이 수신자의 흐름 제어 윈도, 즉 시스템에서 설정된 혼잡 임계치 크기를 넘어서기 전까지 지속되거나 패킷이 손실될 때까지 계속된다. 

그 이후부터는 혼잡 회피알고리즘이 발동한다. 

혼잡 회피에서 암묵적으로 판단하기에 패킷 손실이 일어났다는 것은 네트워크 혼잡이 일어났다는 신호. 
이동 경로의 어딘가에서 정체가 일어난 링크나 라우터가 패킷을 누락시켰을 것이다. 그래서 우리는 네트워크에 부담을 덜어 주고 더이상의 패킷 손실을 막기 위해 윈도 사이즈를 조정해야 하는 것이다.

일단 혼잡 윈도가 리셋되면, 혼잡 회피는 더 이상의 손실을 최소화 하기 위해 얼마나 윈도 크기를 늘려야 할지를 지정한다. 이후 어느시점에서 패킷 손실이 다시 한 번 일어나면 이 과정을 다시 한 번 반복한다. TCP 커넥션의 처리량을 살펴 보다가 톱니모양의 패턴을 한 번이라도 발견한 적이 있다면, 이제 왜 그런 모양이 나왔는지 이해될것이다.  이 패턴의 모습이 네트워크 내의 패킷 손실에 대응하여 혼잡 제어와 회피 알고리즘이 혼잡 윈도 크기를 조정하는 모습인 것이다. 

마지막으로 주목할 만한 점은 연구 분야와 상업 분야 모두에서 혼잡 제어와 회피의 기능을 향상시키기 위한  노력이 활발하다는 사실이다. 

여러 가지 넽ㅡ워크 종류와 다양한 데이터 전송방식 등에 맞는 응용기술 또한 다양하다. 
오늘날 사용하는 플랫폼은 아마 당므 종류 중 한 가지일 것이다. TCP Tahoe와 Reno, TCP Vegas , TCP New Reno , TCP CuBIC(리눅스 기본 설정 ), Compound TCP(Windows 기본 설정) 등이다. 하지만 무엇을 사용하든 혼잡 제어와 회피의 핵심 성능은 모두 동일하다. 

- TCP의 비례속도 감소






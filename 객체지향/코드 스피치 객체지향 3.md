이젠 binder가 model이 변하면 알아서 움직이게 하고싶다 => 옵저버 패턴
binder가 움직이는 방식이 코드로 확장되어있는 부분이 많아서 그부분을 전략적으로 빼내는 방법에 대한 이야길 할 거임


## Strategy

여기서 말하는 Strategy는 어떤 말로 대체할 수 있을까? => 알고리즘도 맞지만 더 범용적으로 보면 도메인. 

프로그램을 짯을때 어떤 문제를 해결하기위한 핵심적인 지식을 말함.

추상적인 개념에서 범용적으로 정의할 수 있다면 얼마든지 처리할 수 있다. 


객체에는 두가지 측면이있음 상태와 행동

행동은 메서드 상태는 프로퍼티로 .

필드값들은 외부에 노출안함 


 ![image](https://github.com/MAGHC/TIL-2024-/assets/89845540/5b7caf40-7dac-4c87-9fd6-6e510d4867d7)

이부분이 전략을 위한 알고리즘 지식 혹은 도메인 이게 전략.

이 전체코드는 구조와 전략으로 이루어져있는것임.

Strategy는 Structure랑 별개로 움직이지는 못함.

이 구조는 이 자료구조를 가지고있을때만 성립할 수 있다. 

특정한 자료구조가 특정한 알고리즘과 맵핑된다.

 = 이전략은 처음부터 특정한 데이터를 지칭할 수 있는 포인터를 가지고있어야만 거기에 맵핑할수있는 알고리즘을 만들수있음.

 지금하고있는건 흔히 짜고있는 코드로 부터 어떻게 전략을 빼내는 지에 대한 발상법을 연구하고있는것. 

 객체지향에선 이부분을 컴포지션으로 해결함

 컴포지션 ? => 코드를 객체로 바꾸는것

 코드를 바꾸게 되면 어떻게되는가 전부다 회귀 테스트를 해야된다. 

전략을 먼저 도출하는데 성공했으면 코드가 구조랑 어떻게 연결되어있는지 잘봐야되고.

그 코드를 객체로 바꿔야된다.

그러나 임의의 객체로 바꾸게되면? 임의의 객체와 이코드가 일반화되어있는 관계를 맺을수없다.

그렇기 떄문에 반드시 ! 인터페이스나 클래스라는 형으로 도출해야지 . 이 형에대해서 이 코드가 반응할수있게만들수있다.

객체로 바꾸고 싶지만. 객체가 여러가지로 들어온다고 생각한다면.

이객체가어떤식의 객체인지 알려주는것을 => Type 

그래서 우린 타입을 정의해야됨.


타입을 정의해서 객체를 받아들이면. 기존 코드에는 의존성이없었지만 

이 객체를 알아야만 렌더가 작동할수있게됨. 


객체지향에서 가장먼저 디펜던시가 발생하는이유는 위임했기떄문이 아님. 나의 전략을 외부에 있는 객체의 도움으로 해결하고싶고 그 이유는 그렇게 하지않으면

변화할때마다 코드를 바꿔야된다. 

이문제를 해결하기위해 코드를 객체로 바꾸면 그 객체에 대한 의존성이 생김

이래서 객체지향은 자연스럽게 객체의존성이 생김.

의존성이 생겼을때 내부에서 의존성 있는 타입의 서브 타입을 만들어내는 게 있고 공급받는게있음

내부에서 만들면? 다시 하드코딩임 그러니까 외부에서 공급받아야.

그래야 내부에는 형에대한 의존성이 있고 특정 객체에대한 의존성이 없을것. 이게 DI 

디펜던시가 만들어지는 순간 DI는 자동이다.

연역적 추리 => 다양한 현상으로부터 원리가되는 추상화가되는 일반성을 도출하는것.


```
const Processor = class{
process(vm,el,k,v,) 를 다 보내줌

```

프로세스한테 다 보내주는데 _process에게 위임 

부모와 자식 사이에 composition이 일어남.

전략을 상속받은 객체한테 위임함.

외부한테 주는게아니라.

디펜던시인젝션의 방향을 외부에서 수입하거나 (주입받거나), 자식과의 injection을 성립시키거나. 

자식한테 인젝션 성립시키는게 Template method임.

외부에서는 process로 보이지만. 
내부에서는 자식쪽으로 인젝션되어있는 method에 의존하고있음

자식쪽으로 의존하고있는 method를 template method에서는 훅이라고부름

템플릿 메소드는 자기가 해야할일을 하는동시에 훅을 이용해서 위임된 부분을 매꿔서 처리하게되어있음.

디자인패턴용어는 몰라도 이 클래스는 process를 외부로 노출되고있는데 내부 자식을 ㅅ용하고있음. 그냥쓰면 throw되니까 

확장한 _process를 가지고있는 애만 무사히 처리 가능 

이미 _process는 추상 클래스로 쓰고있는것.

composition을 di를 통해서 해곃는게 Binder 쪽이고 

Process는 template method를 통해서 해결하려고하는것.

알고리즘은 구조와도 관련이있다. 


구조와 관련이없는 알고리즘은 드물다.

자바스크립트에서 class는 문이 아니라 식이다.  즉시실행 함수 시그니쳐랑 비슷함.

class를 만들면 class는 값이기때문에 new로 해서 생성자로 넘겨줌. 

![image](https://github.com/MAGHC/TIL-2024-/assets/89845540/802b823b-cb0b-4fab-a382-e0c87ea31458)

익명 상속된 클래스의 장점.


![image](https://github.com/MAGHC/TIL-2024-/assets/89845540/988d6673-d0b1-4d5c-90a3-ac02b3cb3fef)


자식이 구현한걸 부모가쓸거야 이정도만해도 어려움.

객체지향은 객체망을 구성해서쓴다고했는데. 

알고리즘의 일반화 추상화라는건 뭐냐면 공통으로 묶었어 제네릭으로 했어 이런게아니라 객체로 뺴고난다음에 

객체를 형으로 빼고 형과 계약하고 형으로 계약된 내용으로 알고리즘을 만드는것을

알고리즘의 일반화라고한다.

어려운건? => 전략객체와 객체 패턴을 사용하기힘든이유?=> 알고리즘일반화가어렵다.

형을 안정화시킬려면 되도록이면 기능이없는게 좋다.

그래야 의존하는애가 코드가 안바뀔것임.

안정화되어있는 일반화되어있는 코드라는건 약속하고있는 내용이 적다는것이기떄문

적은데도 불구하고 일반화하는 능력이 부족해서 전략패턴이 잘안된다.


33:12 
 
